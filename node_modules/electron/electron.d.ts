// Type definitions for Electron 6.1.12
// Project: http://electronjs.org/
// Definitions by: The Electron Team <https://github.com/electron/electron>
// Definitions: https://github.com/electron/electron-typescript-definitions

/// <reference types="node" />

type GlobalEvent = Event;

declare namespace Electron {
  // TODO: Replace this declaration with NodeJS.EventEmitter
  class EventEmitter {
    addListener(event: string, listener: Function): this;
    on(event: string, listener: Function): this;
    once(event: string, listener: Function): this;
    removeListener(event: string, listener: Function): this;
    removeAllListeners(event?: string): this;
    setMaxListeners(n: number): this;
    getMaxListeners(): number;
    listeners(event: string): Function[];
    emit(event: string, ...args: any[]): boolean;
    listenerCount(type: string): number;
    prependListener(event: string, listener: Function): this;
    prependOnceListener(event: string, listener: Function): this;
    eventNames(): Array<(string | symbol)>;
  }

  class Accelerator extends String {

  }

  interface CommonInterface {
    clipboard: Clipboard;
    crashReporter: CrashReporter;
    nativeImage: typeof NativeImage;
    shell: Shell;
  }

  interface MainInterface extends CommonInterface {
    app: App;
    autoUpdater: AutoUpdater;
    BrowserView: typeof BrowserView;
    BrowserWindow: typeof BrowserWindow;
    ClientRequest: typeof ClientRequest;
    contentTracing: ContentTracing;
    Cookies: typeof Cookies;
    Debugger: typeof Debugger;
    dialog: Dialog;
    DownloadItem: typeof DownloadItem;
    globalShortcut: GlobalShortcut;
    inAppPurchase: InAppPurchase;
    IncomingMessage: typeof IncomingMessage;
    ipcMain: IpcMain;
    Menu: typeof Menu;
    MenuItem: typeof MenuItem;
    net: Net;
    netLog: NetLog;
    Notification: typeof Notification;
    powerMonitor: PowerMonitor;
    powerSaveBlocker: PowerSaveBlocker;
    protocol: Protocol;
    screen: Screen;
    session: typeof Session;
    systemPreferences: SystemPreferences;
    TouchBar: typeof TouchBar;
    Tray: typeof Tray;
    webContents: typeof WebContents;
    WebRequest: typeof WebRequest;
  }

  interface RendererInterface extends CommonInterface {
    BrowserWindowProxy: typeof BrowserWindowProxy;
    contextBridge: ContextBridge;
    desktopCapturer: DesktopCapturer;
    ipcRenderer: IpcRenderer;
    remote: Remote;
    webFrame: WebFrame;
    webviewTag: WebviewTag;
  }

  interface AllElectron extends MainInterface, RendererInterface {}

  const app: App;
  const autoUpdater: AutoUpdater;
  const clipboard: Clipboard;
  const contentTracing: ContentTracing;
  const contextBridge: ContextBridge;
  const crashReporter: CrashReporter;
  const desktopCapturer: DesktopCapturer;
  const dialog: Dialog;
  const globalShortcut: GlobalShortcut;
  const inAppPurchase: InAppPurchase;
  const ipcMain: IpcMain;
  const ipcRenderer: IpcRenderer;
  type nativeImage = NativeImage;
  const nativeImage: typeof NativeImage;
  const net: Net;
  const netLog: NetLog;
  const powerMonitor: PowerMonitor;
  const powerSaveBlocker: PowerSaveBlocker;
  const protocol: Protocol;
  const remote: Remote;
  const screen: Screen;
  type session = Session;
  const session: typeof Session;
  const shell: Shell;
  const systemPreferences: SystemPreferences;
  type webContents = WebContents;
  const webContents: typeof WebContents;
  const webFrame: WebFrame;
  const webviewTag: WebviewTag;

  interface App extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/app

    /**
     * Emitted when Chrome's accessibility support changes. This event fires when
     * assistive technologies, such as screen readers, are enabled or disabled. See
     * https://www.chromium.org/developers/design-documents/accessibility for more
     * details.
     */
    on(event: 'accessibility-support-changed', listener: (event: Event,
                                                          /**
                                                           * `true` when Chrome's accessibility support is enabled, `false` otherwise.
                                                           */
                                                          accessibilitySupportEnabled: boolean) => void): this;
    once(event: 'accessibility-support-changed', listener: (event: Event,
                                                          /**
                                                           * `true` when Chrome's accessibility support is enabled, `false` otherwise.
                                                           */
                                                          accessibilitySupportEnabled: boolean) => void): this;
    addListener(event: 'accessibility-support-changed', listener: (event: Event,
                                                          /**
                                                           * `true` when Chrome's accessibility support is enabled, `false` otherwise.
                                                           */
                                                          accessibilitySupportEnabled: boolean) => void): this;
    removeListener(event: 'accessibility-support-changed', listener: (event: Event,
                                                          /**
                                                           * `true` when Chrome's accessibility support is enabled, `false` otherwise.
                                                           */
                                                          accessibilitySupportEnabled: boolean) => void): this;
    /**
     * Emitted when the application is activated. Various actions can trigger this
     * event, such as launching the application for the first time, attempting to
     * re-launch the application when it's already running, or clicking on the
     * application's dock or taskbar icon.
     */
    on(event: 'activate', listener: (event: Event,
                                     hasVisibleWindows: boolean) => void): this;
    once(event: 'activate', listener: (event: Event,
                                     hasVisibleWindows: boolean) => void): this;
    addListener(event: 'activate', listener: (event: Event,
                                     hasVisibleWindows: boolean) => void): this;
    removeListener(event: 'activate', listener: (event: Event,
                                     hasVisibleWindows: boolean) => void): this;
    /**
     * Emitted during Handoff after an activity from this device was successfully
     * resumed on another one.
     */
    on(event: 'activity-was-continued', listener: (event: Event,
                                                   /**
                                                    * A string identifying the activity. Maps to .
                                                    */
                                                   type: string,
                                                   /**
                                                    * Contains app-specific state stored by the activity.
                                                    */
                                                   userInfo: any) => void): this;
    once(event: 'activity-was-continued', listener: (event: Event,
                                                   /**
                                                    * A string identifying the activity. Maps to .
                                                    */
                                                   type: string,
                                                   /**
                                                    * Contains app-specific state stored by the activity.
                                                    */
                                                   userInfo: any) => void): this;
    addListener(event: 'activity-was-continued', listener: (event: Event,
                                                   /**
                                                    * A string identifying the activity. Maps to .
                                                    */
                                                   type: string,
                                                   /**
                                                    * Contains app-specific state stored by the activity.
                                                    */
                                                   userInfo: any) => void): this;
    removeListener(event: 'activity-was-continued', listener: (event: Event,
                                                   /**
                                                    * A string identifying the activity. Maps to .
                                                    */
                                                   type: string,
                                                   /**
                                                    * Contains app-specific state stored by the activity.
                                                    */
                                                   userInfo: any) => void): this;
    /**
     * Emitted before the application starts closing its windows. Calling
     * event.preventDefault() will prevent the default behavior, which is terminating
     * the application. Note: If application quit was initiated by
     * autoUpdater.quitAndInstall(), then before-quit is emitted after emitting close
     * event on all windows and closing them. Note: On Windows, this event will not be
     * emitted if the app is closed due to a shutdown/restart of the system or a user
     * logout.
     */
    on(event: 'before-quit', listener: (event: Event) => void): this;
    once(event: 'before-quit', listener: (event: Event) => void): this;
    addListener(event: 'before-quit', listener: (event: Event) => void): this;
    removeListener(event: 'before-quit', listener: (event: Event) => void): this;
    /**
     * Emitted when a browserWindow gets blurred.
     */
    on(event: 'browser-window-blur', listener: (event: Event,
                                                window: BrowserWindow) => void): this;
    once(event: 'browser-window-blur', listener: (event: Event,
                                                window: BrowserWindow) => void): this;
    addListener(event: 'browser-window-blur', listener: (event: Event,
                                                window: BrowserWindow) => void): this;
    removeListener(event: 'browser-window-blur', listener: (event: Event,
                                                window: BrowserWindow) => void): this;
    /**
     * Emitted when a new browserWindow is created.
     */
    on(event: 'browser-window-created', listener: (event: Event,
                                                   window: BrowserWindow) => void): this;
    once(event: 'browser-window-created', listener: (event: Event,
                                                   window: BrowserWindow) => void): this;
    addListener(event: 'browser-window-created', listener: (event: Event,
                                                   window: BrowserWindow) => void): this;
    removeListener(event: 'browser-window-created', listener: (event: Event,
                                                   window: BrowserWindow) => void): this;
    /**
     * Emitted when a browserWindow gets focused.
     */
    on(event: 'browser-window-focus', listener: (event: Event,
                                                 window: BrowserWindow) => void): this;
    once(event: 'browser-window-focus', listener: (event: Event,
                                                 window: BrowserWindow) => void): this;
    addListener(event: 'browser-window-focus', listener: (event: Event,
                                                 window: BrowserWindow) => void): this;
    removeListener(event: 'browser-window-focus', listener: (event: Event,
                                                 window: BrowserWindow) => void): this;
    /**
     * Emitted when failed to verify the certificate for url, to trust the certificate
     * you should prevent the default behavior with event.preventDefault() and call
     * callback(true).
     */
    on(event: 'certificate-error', listener: (event: Event,
                                              webContents: WebContents,
                                              url: string,
                                              /**
                                               * The error code
                                               */
                                              error: string,
                                              certificate: Certificate,
                                              callback: (isTrusted: boolean) => void) => void): this;
    once(event: 'certificate-error', listener: (event: Event,
                                              webContents: WebContents,
                                              url: string,
                                              /**
                                               * The error code
                                               */
                                              error: string,
                                              certificate: Certificate,
                                              callback: (isTrusted: boolean) => void) => void): this;
    addListener(event: 'certificate-error', listener: (event: Event,
                                              webContents: WebContents,
                                              url: string,
                                              /**
                                               * The error code
                                               */
                                              error: string,
                                              certificate: Certificate,
                                              callback: (isTrusted: boolean) => void) => void): this;
    removeListener(event: 'certificate-error', listener: (event: Event,
                                              webContents: WebContents,
                                              url: string,
                                              /**
                                               * The error code
                                               */
                                              error: string,
                                              certificate: Certificate,
                                              callback: (isTrusted: boolean) => void) => void): this;
    /**
     * Emitted during Handoff when an activity from a different device wants to be
     * resumed. You should call event.preventDefault() if you want to handle this
     * event. A user activity can be continued only in an app that has the same
     * developer Team ID as the activity's source app and that supports the activity's
     * type. Supported activity types are specified in the app's Info.plist under the
     * NSUserActivityTypes key.
     */
    on(event: 'continue-activity', listener: (event: Event,
                                              /**
                                               * A string identifying the activity. Maps to .
                                               */
                                              type: string,
                                              /**
                                               * Contains app-specific state stored by the activity on another device.
                                               */
                                              userInfo: any) => void): this;
    once(event: 'continue-activity', listener: (event: Event,
                                              /**
                                               * A string identifying the activity. Maps to .
                                               */
                                              type: string,
                                              /**
                                               * Contains app-specific state stored by the activity on another device.
                                               */
                                              userInfo: any) => void): this;
    addListener(event: 'continue-activity', listener: (event: Event,
                                              /**
                                               * A string identifying the activity. Maps to .
                                               */
                                              type: string,
                                              /**
                                               * Contains app-specific state stored by the activity on another device.
                                               */
                                              userInfo: any) => void): this;
    removeListener(event: 'continue-activity', listener: (event: Event,
                                              /**
                                               * A string identifying the activity. Maps to .
                                               */
                                              type: string,
                                              /**
                                               * Contains app-specific state stored by the activity on another device.
                                               */
                                              userInfo: any) => void): this;
    /**
     * Emitted during Handoff when an activity from a different device fails to be
     * resumed.
     */
    on(event: 'continue-activity-error', listener: (event: Event,
                                                    /**
                                                     * A string identifying the activity. Maps to .
                                                     */
                                                    type: string,
                                                    /**
                                                     * A string with the error's localized description.
                                                     */
                                                    error: string) => void): this;
    once(event: 'continue-activity-error', listener: (event: Event,
                                                    /**
                                                     * A string identifying the activity. Maps to .
                                                     */
                                                    type: string,
                                                    /**
                                                     * A string with the error's localized description.
                                                     */
                                                    error: string) => void): this;
    addListener(event: 'continue-activity-error', listener: (event: Event,
                                                    /**
                                                     * A string identifying the activity. Maps to .
                                                     */
                                                    type: string,
                                                    /**
                                                     * A string with the error's localized description.
                                                     */
                                                    error: string) => void): this;
    removeListener(event: 'continue-activity-error', listener: (event: Event,
                                                    /**
                                                     * A string identifying the activity. Maps to .
                                                     */
                                                    type: string,
                                                    /**
                                                     * A string with the error's localized description.
                                                     */
                                                    error: string) => void): this;
    /**
     * Emitted when desktopCapturer.getSources() is called in the renderer process of
     * webContents. Calling event.preventDefault() will make it return empty sources.
     */
    on(event: 'desktop-capturer-get-sources', listener: (event: Event,
                                                         webContents: WebContents) => void): this;
    once(event: 'desktop-capturer-get-sources', listener: (event: Event,
                                                         webContents: WebContents) => void): this;
    addListener(event: 'desktop-capturer-get-sources', listener: (event: Event,
                                                         webContents: WebContents) => void): this;
    removeListener(event: 'desktop-capturer-get-sources', listener: (event: Event,
                                                         webContents: WebContents) => void): this;
    /**
     * Emitted when the gpu process crashes or is killed.
     */
    on(event: 'gpu-process-crashed', listener: (event: Event,
                                                killed: boolean) => void): this;
    once(event: 'gpu-process-crashed', listener: (event: Event,
                                                killed: boolean) => void): this;
    addListener(event: 'gpu-process-crashed', listener: (event: Event,
                                                killed: boolean) => void): this;
    removeListener(event: 'gpu-process-crashed', listener: (event: Event,
                                                killed: boolean) => void): this;
    /**
     * Emitted when webContents wants to do basic auth. The default behavior is to
     * cancel all authentications. To override this you should prevent the default
     * behavior with event.preventDefault() and call callback(username, password) with
     * the credentials.
     */
    on(event: 'login', listener: (event: Event,
                                  webContents: WebContents,
                                  request: Request,
                                  authInfo: AuthInfo,
                                  callback: (username: string, password: string) => void) => void): this;
    once(event: 'login', listener: (event: Event,
                                  webContents: WebContents,
                                  request: Request,
                                  authInfo: AuthInfo,
                                  callback: (username: string, password: string) => void) => void): this;
    addListener(event: 'login', listener: (event: Event,
                                  webContents: WebContents,
                                  request: Request,
                                  authInfo: AuthInfo,
                                  callback: (username: string, password: string) => void) => void): this;
    removeListener(event: 'login', listener: (event: Event,
                                  webContents: WebContents,
                                  request: Request,
                                  authInfo: AuthInfo,
                                  callback: (username: string, password: string) => void) => void): this;
    /**
     * Emitted when the user clicks the native macOS new tab button. The new tab button
     * is only visible if the current BrowserWindow has a tabbingIdentifier
     */
    on(event: 'new-window-for-tab', listener: (event: Event) => void): this;
    once(event: 'new-window-for-tab', listener: (event: Event) => void): this;
    addListener(event: 'new-window-for-tab', listener: (event: Event) => void): this;
    removeListener(event: 'new-window-for-tab', listener: (event: Event) => void): this;
    /**
     * Emitted when the user wants to open a file with the application. The open-file
     * event is usually emitted when the application is already open and the OS wants
     * to reuse the application to open the file. open-file is also emitted when a file
     * is dropped onto the dock and the application is not yet running. Make sure to
     * listen for the open-file event very early in your application startup to handle
     * this case (even before the ready event is emitted). You should call
     * event.preventDefault() if you want to handle this event. On Windows, you have to
     * parse process.argv (in the main process) to get the filepath.
     */
    on(event: 'open-file', listener: (event: Event,
                                      path: string) => void): this;
    once(event: 'open-file', listener: (event: Event,
                                      path: string) => void): this;
    addListener(event: 'open-file', listener: (event: Event,
                                      path: string) => void): this;
    removeListener(event: 'open-file', listener: (event: Event,
                                      path: string) => void): this;
    /**
     * Emitted when the user wants to open a URL with the application. Your
     * application's Info.plist file must define the url scheme within the
     * CFBundleURLTypes key, and set NSPrincipalClass to AtomApplication. You should
     * call event.preventDefault() if you want to handle this event.
     */
    on(event: 'open-url', listener: (event: Event,
                                     url: string) => void): this;
    once(event: 'open-url', listener: (event: Event,
                                     url: string) => void): this;
    addListener(event: 'open-url', listener: (event: Event,
                                     url: string) => void): this;
    removeListener(event: 'open-url', listener: (event: Event,
                                     url: string) => void): this;
    /**
     * Emitted when the application is quitting. Note: On Windows, this event will not
     * be emitted if the app is closed due to a shutdown/restart of the system or a
     * user logout.
     */
    on(event: 'quit', listener: (event: Event,
                                 exitCode: number) => void): this;
    once(event: 'quit', listener: (event: Event,
                                 exitCode: number) => void): this;
    addListener(event: 'quit', listener: (event: Event,
                                 exitCode: number) => void): this;
    removeListener(event: 'quit', listener: (event: Event,
                                 exitCode: number) => void): this;
    /**
     * Emitted when Electron has finished initializing. On macOS, launchInfo holds the
     * userInfo of the NSUserNotification that was used to open the application, if it
     * was launched from Notification Center. You can call app.isReady() to check if
     * this event has already fired.
     */
    on(event: 'ready', listener: (launchInfo: any) => void): this;
    once(event: 'ready', listener: (launchInfo: any) => void): this;
    addListener(event: 'ready', listener: (launchInfo: any) => void): this;
    removeListener(event: 'ready', listener: (launchInfo: any) => void): this;
    /**
     * Emitted when remote.getBuiltin() is called in the renderer process of
     * webContents. Calling event.preventDefault() will prevent the module from being
     * returned. Custom value can be returned by setting event.returnValue.
     */
    on(event: 'remote-get-builtin', listener: (event: Event,
                                               webContents: WebContents,
                                               moduleName: string) => void): this;
    once(event: 'remote-get-builtin', listener: (event: Event,
                                               webContents: WebContents,
                                               moduleName: string) => void): this;
    addListener(event: 'remote-get-builtin', listener: (event: Event,
                                               webContents: WebContents,
                                               moduleName: string) => void): this;
    removeListener(event: 'remote-get-builtin', listener: (event: Event,
                                               webContents: WebContents,
                                               moduleName: string) => void): this;
    /**
     * Emitted when remote.getCurrentWebContents() is called in the renderer process of
     * webContents. Calling event.preventDefault() will prevent the object from being
     * returned. Custom value can be returned by setting event.returnValue.
     */
    on(event: 'remote-get-current-web-contents', listener: (event: Event,
                                                            webContents: WebContents) => void): this;
    once(event: 'remote-get-current-web-contents', listener: (event: Event,
                                                            webContents: WebContents) => void): this;
    addListener(event: 'remote-get-current-web-contents', listener: (event: Event,
                                                            webContents: WebContents) => void): this;
    removeListener(event: 'remote-get-current-web-contents', listener: (event: Event,
                                                            webContents: WebContents) => void): this;
    /**
     * Emitted when remote.getCurrentWindow() is called in the renderer process of
     * webContents. Calling event.preventDefault() will prevent the object from being
     * returned. Custom value can be returned by setting event.returnValue.
     */
    on(event: 'remote-get-current-window', listener: (event: Event,
                                                      webContents: WebContents) => void): this;
    once(event: 'remote-get-current-window', listener: (event: Event,
                                                      webContents: WebContents) => void): this;
    addListener(event: 'remote-get-current-window', listener: (event: Event,
                                                      webContents: WebContents) => void): this;
    removeListener(event: 'remote-get-current-window', listener: (event: Event,
                                                      webContents: WebContents) => void): this;
    /**
     * Emitted when remote.getGlobal() is called in the renderer process of
     * webContents. Calling event.preventDefault() will prevent the global from being
     * returned. Custom value can be returned by setting event.returnValue.
     */
    on(event: 'remote-get-global', listener: (event: Event,
                                              webContents: WebContents,
                                              globalName: string) => void): this;
    once(event: 'remote-get-global', listener: (event: Event,
                                              webContents: WebContents,
                                              globalName: string) => void): this;
    addListener(event: 'remote-get-global', listener: (event: Event,
                                              webContents: WebContents,
                                              globalName: string) => void): this;
    removeListener(event: 'remote-get-global', listener: (event: Event,
                                              webContents: WebContents,
                                              globalName: string) => void): this;
    /**
     * Emitted when <webview>.getWebContents() is called in the renderer process of
     * webContents. Calling event.preventDefault() will prevent the object from being
     * returned. Custom value can be returned by setting event.returnValue.
     */
    on(event: 'remote-get-guest-web-contents', listener: (event: Event,
                                                          webContents: WebContents,
                                                          guestWebContents: WebContents) => void): this;
    once(event: 'remote-get-guest-web-contents', listener: (event: Event,
                                                          webContents: WebContents,
                                                          guestWebContents: WebContents) => void): this;
    addListener(event: 'remote-get-guest-web-contents', listener: (event: Event,
                                                          webContents: WebContents,
                                                          guestWebContents: WebContents) => void): this;
    removeListener(event: 'remote-get-guest-web-contents', listener: (event: Event,
                                                          webContents: WebContents,
                                                          guestWebContents: WebContents) => void): this;
    /**
     * Emitted when remote.require() is called in the renderer process of webContents.
     * Calling event.preventDefault() will prevent the module from being returned.
     * Custom value can be returned by setting event.returnValue.
     */
    on(event: 'remote-require', listener: (event: Event,
                                           webContents: WebContents,
                                           moduleName: string) => void): this;
    once(event: 'remote-require', listener: (event: Event,
                                           webContents: WebContents,
                                           moduleName: string) => void): this;
    addListener(event: 'remote-require', listener: (event: Event,
                                           webContents: WebContents,
                                           moduleName: string) => void): this;
    removeListener(event: 'remote-require', listener: (event: Event,
                                           webContents: WebContents,
                                           moduleName: string) => void): this;
    /**
     * Emitted when the renderer process of webContents crashes or is killed.
     */
    on(event: 'renderer-process-crashed', listener: (event: Event,
                                                     webContents: WebContents,
                                                     killed: boolean) => void): this;
    once(event: 'renderer-process-crashed', listener: (event: Event,
                                                     webContents: WebContents,
                                                     killed: boolean) => void): this;
    addListener(event: 'renderer-process-crashed', listener: (event: Event,
                                                     webContents: WebContents,
                                                     killed: boolean) => void): this;
    removeListener(event: 'renderer-process-crashed', listener: (event: Event,
                                                     webContents: WebContents,
                                                     killed: boolean) => void): this;
    /**
     * This event will be emitted inside the primary instance of your application when
     * a second instance has been executed and calls app.requestSingleInstanceLock().
     * argv is an Array of the second instance's command line arguments, and
     * workingDirectory is its current working directory. Usually applications respond
     * to this by making their primary window focused and non-minimized. This event is
     * guaranteed to be emitted after the ready event of app gets emitted. Note: Extra
     * command line arguments might be added by Chromium, such as
     * --original-process-start-time.
     */
    on(event: 'second-instance', listener: (event: Event,
                                            /**
                                             * An array of the second instance's command line arguments
                                             */
                                            argv: string[],
                                            /**
                                             * The second instance's working directory
                                             */
                                            workingDirectory: string) => void): this;
    once(event: 'second-instance', listener: (event: Event,
                                            /**
                                             * An array of the second instance's command line arguments
                                             */
                                            argv: string[],
                                            /**
                                             * The second instance's working directory
                                             */
                                            workingDirectory: string) => void): this;
    addListener(event: 'second-instance', listener: (event: Event,
                                            /**
                                             * An array of the second instance's command line arguments
                                             */
                                            argv: string[],
                                            /**
                                             * The second instance's working directory
                                             */
                                            workingDirectory: string) => void): this;
    removeListener(event: 'second-instance', listener: (event: Event,
                                            /**
                                             * An array of the second instance's command line arguments
                                             */
                                            argv: string[],
                                            /**
                                             * The second instance's working directory
                                             */
                                            workingDirectory: string) => void): this;
    /**
     * Emitted when a client certificate is requested. The url corresponds to the
     * navigation entry requesting the client certificate and callback can be called
     * with an entry filtered from the list. Using event.preventDefault() prevents the
     * application from using the first certificate from the store.
     */
    on(event: 'select-client-certificate', listener: (event: Event,
                                                      webContents: WebContents,
                                                      url: string,
                                                      certificateList: Certificate[],
                                                      callback: (certificate?: Certificate) => void) => void): this;
    once(event: 'select-client-certificate', listener: (event: Event,
                                                      webContents: WebContents,
                                                      url: string,
                                                      certificateList: Certificate[],
                                                      callback: (certificate?: Certificate) => void) => void): this;
    addListener(event: 'select-client-certificate', listener: (event: Event,
                                                      webContents: WebContents,
                                                      url: string,
                                                      certificateList: Certificate[],
                                                      callback: (certificate?: Certificate) => void) => void): this;
    removeListener(event: 'select-client-certificate', listener: (event: Event,
                                                      webContents: WebContents,
                                                      url: string,
                                                      certificateList: Certificate[],
                                                      callback: (certificate?: Certificate) => void) => void): this;
    /**
     * Emitted when Electron has created a new session.
     */
    on(event: 'session-created', listener: (session: Session) => void): this;
    once(event: 'session-created', listener: (session: Session) => void): this;
    addListener(event: 'session-created', listener: (session: Session) => void): this;
    removeListener(event: 'session-created', listener: (session: Session) => void): this;
    /**
     * Emitted when Handoff is about to be resumed on another device. If you need to
     * update the state to be transferred, you should call event.preventDefault()
     * immediately, construct a new userInfo dictionary and call
     * app.updateCurrentActiviy() in a timely manner. Otherwise, the operation will
     * fail and continue-activity-error will be called.
     */
    on(event: 'update-activity-state', listener: (event: Event,
                                                  /**
                                                   * A string identifying the activity. Maps to .
                                                   */
                                                  type: string,
                                                  /**
                                                   * Contains app-specific state stored by the activity.
                                                   */
                                                  userInfo: any) => void): this;
    once(event: 'update-activity-state', listener: (event: Event,
                                                  /**
                                                   * A string identifying the activity. Maps to .
                                                   */
                                                  type: string,
                                                  /**
                                                   * Contains app-specific state stored by the activity.
                                                   */
                                                  userInfo: any) => void): this;
    addListener(event: 'update-activity-state', listener: (event: Event,
                                                  /**
                                                   * A string identifying the activity. Maps to .
                                                   */
                                                  type: string,
                                                  /**
                                                   * Contains app-specific state stored by the activity.
                                                   */
                                                  userInfo: any) => void): this;
    removeListener(event: 'update-activity-state', listener: (event: Event,
                                                  /**
                                                   * A string identifying the activity. Maps to .
                                                   */
                                                  type: string,
                                                  /**
                                                   * Contains app-specific state stored by the activity.
                                                   */
                                                  userInfo: any) => void): this;
    /**
     * Emitted when a new webContents is created.
     */
    on(event: 'web-contents-created', listener: (event: Event,
                                                 webContents: WebContents) => void): this;
    once(event: 'web-contents-created', listener: (event: Event,
                                                 webContents: WebContents) => void): this;
    addListener(event: 'web-contents-created', listener: (event: Event,
                                                 webContents: WebContents) => void): this;
    removeListener(event: 'web-contents-created', listener: (event: Event,
                                                 webContents: WebContents) => void): this;
    /**
     * Emitted during Handoff before an activity from a different device wants to be
     * resumed. You should call event.preventDefault() if you want to handle this
     * event.
     */
    on(event: 'will-continue-activity', listener: (event: Event,
                                                   /**
                                                    * A string identifying the activity. Maps to .
                                                    */
                                                   type: string) => void): this;
    once(event: 'will-continue-activity', listener: (event: Event,
                                                   /**
                                                    * A string identifying the activity. Maps to .
                                                    */
                                                   type: string) => void): this;
    addListener(event: 'will-continue-activity', listener: (event: Event,
                                                   /**
                                                    * A string identifying the activity. Maps to .
                                                    */
                                                   type: string) => void): this;
    removeListener(event: 'will-continue-activity', listener: (event: Event,
                                                   /**
                                                    * A string identifying the activity. Maps to .
                                                    */
                                                   type: string) => void): this;
    /**
     * Emitted when the application has finished basic startup. On Windows and Linux,
     * the will-finish-launching event is the same as the ready event; on macOS, this
     * event represents the applicationWillFinishLaunching notification of
     * NSApplication. You would usually set up listeners for the open-file and open-url
     * events here, and start the crash reporter and auto updater. In most cases, you
     * should do everything in the ready event handler.
     */
    on(event: 'will-finish-launching', listener: Function): this;
    once(event: 'will-finish-launching', listener: Function): this;
    addListener(event: 'will-finish-launching', listener: Function): this;
    removeListener(event: 'will-finish-launching', listener: Function): this;
    /**
     * Emitted when all windows have been closed and the application will quit. Calling
     * event.preventDefault() will prevent the default behaviour, which is terminating
     * the application. See the description of the window-all-closed event for the
     * differences between the will-quit and window-all-closed events. Note: On
     * Windows, this event will not be emitted if the app is closed due to a
     * shutdown/restart of the system or a user logout.
     */
    on(event: 'will-quit', listener: (event: Event) => void): this;
    once(event: 'will-quit', listener: (event: Event) => void): this;
    addListener(event: 'will-quit', listener: (event: Event) => void): this;
    removeListener(event: 'will-quit', listener: (event: Event) => void): this;
    /**
     * Emitted when all windows have been closed. If you do not subscribe to this event
     * and all windows are closed, the default behavior is to quit the app; however, if
     * you subscribe, you control whether the app quits or not. If the user pressed Cmd
     * + Q, or the developer called app.quit(), Electron will first try to close all
     * the windows and then emit the will-quit event, and in this case the
     * window-all-closed event would not be emitted.
     */
    on(event: 'window-all-closed', listener: Function): this;
    once(event: 'window-all-closed', listener: Function): this;
    addListener(event: 'window-all-closed', listener: Function): this;
    removeListener(event: 'window-all-closed', listener: Function): this;
    /**
     * Adds path to the recent documents list. This list is managed by the OS. On
     * Windows, you can visit the list from the task bar, and on macOS, you can visit
     * it from dock menu.
     */
    addRecentDocument(path: string): void;
    /**
     * Clears the recent documents list.
     */
    clearRecentDocuments(): void;
    /**
     * By default, Chromium disables 3D APIs (e.g. WebGL) until restart on a per domain
     * basis if the GPU processes crashes too frequently. This function disables that
     * behaviour. This method can only be called before app is ready.
     */
    disableDomainBlockingFor3DAPIs(): void;
    /**
     * Disables hardware acceleration for current app. This method can only be called
     * before app is ready.
     */
    disableHardwareAcceleration(): void;
    /**
     * Enables full sandbox mode on the app. This method can only be called before app
     * is ready.
     */
    enableSandbox(): void;
    /**
     * Exits immediately with exitCode. exitCode defaults to 0. All windows will be
     * closed immediately without asking the user, and the before-quit and will-quit
     * events will not be emitted.
     */
    exit(exitCode?: number): void;
    /**
     * On Linux, focuses on the first visible window. On macOS, makes the application
     * the active app. On Windows, focuses on the application's first window.
     */
    focus(): void;
    getAppMetrics(): ProcessMetric[];
    getAppPath(): string;
    getBadgeCount(): number;
    getCurrentActivityType(): string;
    /**
     * Fetches a path's associated icon. On Windows, there a 2 kinds of icons: On Linux
     * and macOS, icons depend on the application associated with file mime type.
     */
    getFileIcon(path: string, options?: FileIconOptions): Promise<Electron.NativeImage>;
    /**
     * Fetches a path's associated icon. On Windows, there are 2 kinds of icons: On
     * Linux and macOS, icons depend on the application associated with file mime type.
     * Deprecated Soon
     */
    getFileIcon(path: string, options: FileIconOptions, callback: (error: Error, icon: NativeImage) => void): void;
    /**
     * Fetches a path's associated icon. On Windows, there are 2 kinds of icons: On
     * Linux and macOS, icons depend on the application associated with file mime type.
     * Deprecated Soon
     */
    getFileIcon(path: string, callback: (error: Error, icon: NativeImage) => void): void;
    getGPUFeatureStatus(): GPUFeatureStatus;
    /**
     * For infoType equal to complete: Promise is fulfilled with Object containing all
     * the GPU Information as in chromium's GPUInfo object. This includes the version
     * and driver information that's shown on chrome://gpu page. For infoType equal to
     * basic: Promise is fulfilled with Object containing fewer attributes than when
     * requested with complete. Here's an example of basic response: Using basic should
     * be preferred if only basic information like vendorId or driverId is needed.
     */
    getGPUInfo(infoType: string): Promise<any>;
    getJumpListSettings(): JumpListSettings;
    /**
     * To set the locale, you'll want to use a command line switch at app startup,
     * which may be found here. Note: When distributing your packaged app, you have to
     * also ship the locales folder. Note: On Windows, you have to call it after the
     * ready events gets emitted.
     */
    getLocale(): string;
    /**
     * Note: When unable to detect locale country code, it returns empty string.
     */
    getLocaleCountryCode(): string;
    /**
     * If you provided path and args options to app.setLoginItemSettings, then you need
     * to pass the same arguments here for openAtLogin to be set correctly.
     */
    getLoginItemSettings(options?: LoginItemSettingsOptions): LoginItemSettings;
    /**
     * Usually the name field of package.json is a short lowercased name, according to
     * the npm modules spec. You should usually also specify a productName field, which
     * is your application's full capitalized name, and which will be preferred over
     * name by Electron.
     */
    getName(): string;
    /**
     * You can request the following paths by the name:
     */
    getPath(name: string): string;
    getVersion(): string;
    /**
     * This method returns whether or not this instance of your app is currently
     * holding the single instance lock.  You can request the lock with
     * app.requestSingleInstanceLock() and release with app.releaseSingleInstanceLock()
     */
    hasSingleInstanceLock(): boolean;
    /**
     * Hides all application windows without minimizing them.
     */
    hide(): void;
    /**
     * Imports the certificate in pkcs12 format into the platform certificate store.
     * callback is called with the result of import operation, a value of 0 indicates
     * success while any other value indicates failure according to Chromium
     * net_error_list.
     */
    importCertificate(options: ImportCertificateOptions, callback: (result: number) => void): void;
    /**
     * Invalidates the current Handoff user activity.
     */
    invalidateCurrentActivity(type: string): void;
    /**
     * Deprecated Soon
     */
    isAccessibilitySupportEnabled(): boolean;
    /**
     * This method checks if the current executable is the default handler for a
     * protocol (aka URI scheme). If so, it will return true. Otherwise, it will return
     * false. Note: On macOS, you can use this method to check if the app has been
     * registered as the default protocol handler for a protocol. You can also verify
     * this by checking ~/Library/Preferences/com.apple.LaunchServices.plist on the
     * macOS machine. Please refer to Apple's documentation for details. The API uses
     * the Windows Registry and LSCopyDefaultHandlerForURLScheme internally.
     */
    isDefaultProtocolClient(protocol: string, path?: string, args?: string[]): boolean;
    isEmojiPanelSupported(): boolean;
    isInApplicationsFolder(): boolean;
    isReady(): boolean;
    isUnityRunning(): boolean;
    /**
     * No confirmation dialog will be presented by default. If you wish to allow the
     * user to confirm the operation, you may do so using the dialog API. NOTE: This
     * method throws errors if anything other than the user causes the move to fail.
     * For instance if the user cancels the authorization dialog, this method returns
     * false. If we fail to perform the copy, then this method will throw an error. The
     * message in the error should be informative and tell you exactly what went wrong
     */
    moveToApplicationsFolder(): boolean;
    /**
     * Try to close all windows. The before-quit event will be emitted first. If all
     * windows are successfully closed, the will-quit event will be emitted and by
     * default the application will terminate. This method guarantees that all
     * beforeunload and unload event handlers are correctly executed. It is possible
     * that a window cancels the quitting by returning false in the beforeunload event
     * handler.
     */
    quit(): void;
    /**
     * Relaunches the app when current instance exits. By default, the new instance
     * will use the same working directory and command line arguments with current
     * instance. When args is specified, the args will be passed as command line
     * arguments instead. When execPath is specified, the execPath will be executed for
     * relaunch instead of current app. Note that this method does not quit the app
     * when executed, you have to call app.quit or app.exit after calling app.relaunch
     * to make the app restart. When app.relaunch is called for multiple times,
     * multiple instances will be started after current instance exited. An example of
     * restarting current instance immediately and adding a new command line argument
     * to the new instance:
     */
    relaunch(options?: RelaunchOptions): void;
    /**
     * Releases all locks that were created by requestSingleInstanceLock. This will
     * allow multiple instances of the application to once again run side by side.
     */
    releaseSingleInstanceLock(): void;
    /**
     * This method checks if the current executable as the default handler for a
     * protocol (aka URI scheme). If so, it will remove the app as the default handler.
     */
    removeAsDefaultProtocolClient(protocol: string, path?: string, args?: string[]): boolean;
    /**
     * The return value of this method indicates whether or not this instance of your
     * application successfully obtained the lock.  If it failed to obtain the lock,
     * you can assume that another instance of your application is already running with
     * the lock and exit immediately. I.e. This method returns true if your process is
     * the primary instance of your application and your app should continue loading.
     * It returns false if your process should immediately quit as it has sent its
     * parameters to another instance that has already acquired the lock. On macOS, the
     * system enforces single instance automatically when users try to open a second
     * instance of your app in Finder, and the open-file and open-url events will be
     * emitted for that. However when users start your app in command line, the
     * system's single instance mechanism will be bypassed, and you have to use this
     * method to ensure single instance. An example of activating the window of primary
     * instance when a second instance starts:
     */
    requestSingleInstanceLock(): boolean;
    /**
     * Set the about panel options. This will override the values defined in the app's
     * .plist file on MacOS. See the Apple docs for more details. On Linux, values must
     * be set in order to be shown; there are no defaults. If you do not set credits
     * but still wish to surface them in your app, AppKit will look for a file named
     * "Credits.html", "Credits.rtf", and "Credits.rtfd", in that order, in the bundle
     * returned by the NSBundle class method main. The first file found is used, and if
     * none is found, the info area is left blank. See Apple documentation for more
     * information.
     */
    setAboutPanelOptions(options: AboutPanelOptionsOptions): void;
    /**
     * Manually enables Chrome's accessibility support, allowing to expose
     * accessibility switch to users in application settings. See Chromium's
     * accessibility docs for more details. Disabled by default. This API must be
     * called after the ready event is emitted. Note: Rendering accessibility tree can
     * significantly affect the performance of your app. It should not be enabled by
     * default. Deprecated Soon
     */
    setAccessibilitySupportEnabled(enabled: boolean): void;
    /**
     * Sets or creates a directory your app's logs which can then be manipulated with
     * app.getPath() or app.setPath(pathName, newPath). Calling app.setAppLogsPath()
     * without a path parameter will result in this directory being set to
     * /Library/Logs/YourAppName on macOS, and inside the userData directory on Linux
     * and Windows.
     */
    setAppLogsPath(path?: string): void;
    /**
     * Changes the Application User Model ID to id.
     */
    setAppUserModelId(id: string): void;
    /**
     * This method sets the current executable as the default handler for a protocol
     * (aka URI scheme). It allows you to integrate your app deeper into the operating
     * system. Once registered, all links with your-protocol:// will be opened with the
     * current executable. The whole link, including protocol, will be passed to your
     * application as a parameter. On Windows, you can provide optional parameters
     * path, the path to your executable, and args, an array of arguments to be passed
     * to your executable when it launches. Note: On macOS, you can only register
     * protocols that have been added to your app's info.plist, which can not be
     * modified at runtime. You can however change the file with a simple text editor
     * or script during build time. Please refer to Apple's documentation for details.
     * Note: In a Windows Store environment (when packaged as an appx) this API will
     * return true for all calls but the registry key it sets won't be accessible by
     * other applications.  In order to register your Windows Store application as a
     * default protocol handler you must declare the protocol in your manifest. The API
     * uses the Windows Registry and LSSetDefaultHandlerForURLScheme internally.
     */
    setAsDefaultProtocolClient(protocol: string, path?: string, args?: string[]): boolean;
    /**
     * Sets the counter badge for current app. Setting the count to 0 will hide the
     * badge. On macOS, it shows on the dock icon. On Linux, it only works for Unity
     * launcher. Note: Unity launcher requires the existence of a .desktop file to
     * work, for more information please read Desktop Environment Integration.
     */
    setBadgeCount(count: number): boolean;
    /**
     * Sets or removes a custom Jump List for the application, and returns one of the
     * following strings: If categories is null the previously set custom Jump List (if
     * any) will be replaced by the standard Jump List for the app (managed by
     * Windows). Note: If a JumpListCategory object has neither the type nor the name
     * property set then its type is assumed to be tasks. If the name property is set
     * but the type property is omitted then the type is assumed to be custom. Note:
     * Users can remove items from custom categories, and Windows will not allow a
     * removed item to be added back into a custom category until after the next
     * successful call to app.setJumpList(categories). Any attempt to re-add a removed
     * item to a custom category earlier than that will result in the entire custom
     * category being omitted from the Jump List. The list of removed items can be
     * obtained using app.getJumpListSettings(). Here's a very simple example of
     * creating a custom Jump List:
     */
    setJumpList(categories: JumpListCategory[]): void;
    /**
     * Set the app's login item settings. To work with Electron's autoUpdater on
     * Windows, which uses Squirrel, you'll want to set the launch path to Update.exe,
     * and pass arguments that specify your application name. For example:
     */
    setLoginItemSettings(settings: Settings): void;
    /**
     * Overrides the current application's name.
     */
    setName(name: string): void;
    /**
     * Overrides the path to a special directory or file associated with name. If the
     * path specifies a directory that does not exist, an Error is thrown. In that
     * case, the directory should be created with fs.mkdirSync or similar. You can only
     * override paths of a name defined in app.getPath. By default, web pages' cookies
     * and caches will be stored under the userData directory. If you want to change
     * this location, you have to override the userData path before the ready event of
     * the app module is emitted.
     */
    setPath(name: string, path: string): void;
    /**
     * Creates an NSUserActivity and sets it as the current activity. The activity is
     * eligible for Handoff to another device afterward.
     */
    setUserActivity(type: string, userInfo: any, webpageURL?: string): void;
    /**
     * Adds tasks to the Tasks category of the JumpList on Windows. tasks is an array
     * of Task objects. Note: If you'd like to customize the Jump List even more use
     * app.setJumpList(categories) instead.
     */
    setUserTasks(tasks: Task[]): boolean;
    /**
     * Shows application windows after they were hidden. Does not automatically focus
     * them.
     */
    show(): void;
    /**
     * Show the app's about panel options. These options can be overridden with
     * app.setAboutPanelOptions(options).
     */
    showAboutPanel(): void;
    /**
     * Show the platform's native emoji picker.
     */
    showEmojiPanel(): void;
    /**
     * Start accessing a security scoped resource. With this method Electron
     * applications that are packaged for the Mac App Store may reach outside their
     * sandbox to access files chosen by the user. See Apple's documentation for a
     * description of how this system works.
     */
    startAccessingSecurityScopedResource(bookmarkData: string): Function;
    /**
     * Updates the current activity if its type matches type, merging the entries from
     * userInfo into its current userInfo dictionary.
     */
    updateCurrentActivity(type: string, userInfo: any): void;
    whenReady(): Promise<void>;
    /**
     * A Boolean property that's true if Chrome's accessibility support is enabled,
     * false otherwise. This property will be true if the use of assistive
     * technologies, such as screen readers, has been detected. Setting this property
     * to true manually enables Chrome's accessibility support, allowing developers to
     * expose accessibility switch to users in application settings. See Chromium's
     * accessibility docs for more details. Disabled by default. This API must be
     * called after the ready event is emitted. Note: Rendering accessibility tree can
     * significantly affect the performance of your app. It should not be enabled by
     * default.
     */
    accessibilitySupportEnabled?: boolean;
    /**
     * A Boolean which when true disables the overrides that Electron has in place to
     * ensure renderer processes are restarted on every navigation.  The current
     * default value for this property is false. The intention is for these overrides
     * to become disabled by default and then at some point in the future this property
     * will be removed.  This property impacts which native modules you can use in the
     * renderer process.  For more information on the direction Electron is going with
     * renderer process restarts and usage of native modules in the renderer process
     * please check out this Tracking Issue.
     */
    allowRendererProcessReuse?: boolean;
    /**
     * A Menu property that return Menu if one has been set and null otherwise. Users
     * can pass a Menu to set this property.
     */
    applicationMenu?: Menu;
    commandLine: CommandLine;
    dock: Dock;
    /**
     * A Boolean property that returns  true if the app is packaged, false otherwise.
     * For many apps, this property can be used to distinguish development and
     * production environments.
     */
    isPackaged?: boolean;
    /**
     * A String which is the user agent string Electron will use as a global fallback.
     * This is the user agent that will be used when no user agent is set at the
     * webContents or session level.  Useful for ensuring your entire app has the same
     * user agent.  Set to a custom value as early as possible in your apps
     * initialization to ensure that your overridden value is used.
     */
    userAgentFallback?: string;
  }

  interface AutoUpdater extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/auto-updater

    /**
     * This event is emitted after a user calls quitAndInstall(). When this API is
     * called, the before-quit event is not emitted before all windows are closed. As a
     * result you should listen to this event if you wish to perform actions before the
     * windows are closed while a process is quitting, as well as listening to
     * before-quit.
     */
    on(event: 'before-quit-for-update', listener: Function): this;
    once(event: 'before-quit-for-update', listener: Function): this;
    addListener(event: 'before-quit-for-update', listener: Function): this;
    removeListener(event: 'before-quit-for-update', listener: Function): this;
    /**
     * Emitted when checking if an update has started.
     */
    on(event: 'checking-for-update', listener: Function): this;
    once(event: 'checking-for-update', listener: Function): this;
    addListener(event: 'checking-for-update', listener: Function): this;
    removeListener(event: 'checking-for-update', listener: Function): this;
    /**
     * Emitted when there is an error while updating.
     */
    on(event: 'error', listener: (error: Error) => void): this;
    once(event: 'error', listener: (error: Error) => void): this;
    addListener(event: 'error', listener: (error: Error) => void): this;
    removeListener(event: 'error', listener: (error: Error) => void): this;
    /**
     * Emitted when there is an available update. The update is downloaded
     * automatically.
     */
    on(event: 'update-available', listener: Function): this;
    once(event: 'update-available', listener: Function): this;
    addListener(event: 'update-available', listener: Function): this;
    removeListener(event: 'update-available', listener: Function): this;
    /**
     * Emitted when an update has been downloaded. On Windows only releaseName is
     * available. Note: It is not strictly necessary to handle this event. A
     * successfully downloaded update will still be applied the next time the
     * application starts.
     */
    on(event: 'update-downloaded', listener: (event: Event,
                                              releaseNotes: string,
                                              releaseName: string,
                                              releaseDate: Date,
                                              updateURL: string) => void): this;
    once(event: 'update-downloaded', listener: (event: Event,
                                              releaseNotes: string,
                                              releaseName: string,
                                              releaseDate: Date,
                                              updateURL: string) => void): this;
    addListener(event: 'update-downloaded', listener: (event: Event,
                                              releaseNotes: string,
                                              releaseName: string,
                                              releaseDate: Date,
                                              updateURL: string) => void): this;
    removeListener(event: 'update-downloaded', listener: (event: Event,
                                              releaseNotes: string,
                                              releaseName: string,
                                              releaseDate: Date,
                                              updateURL: string) => void): this;
    /**
     * Emitted when there is no available update.
     */
    on(event: 'update-not-available', listener: Function): this;
    once(event: 'update-not-available', listener: Function): this;
    addListener(event: 'update-not-available', listener: Function): this;
    removeListener(event: 'update-not-available', listener: Function): this;
    /**
     * Asks the server whether there is an update. You must call setFeedURL before
     * using this API.
     */
    checkForUpdates(): void;
    getFeedURL(): string;
    /**
     * Restarts the app and installs the update after it has been downloaded. It should
     * only be called after update-downloaded has been emitted. Under the hood calling
     * autoUpdater.quitAndInstall() will close all application windows first, and
     * automatically call app.quit() after all windows have been closed. Note: It is
     * not strictly necessary to call this function to apply an update, as a
     * successfully downloaded update will always be applied the next time the
     * application starts.
     */
    quitAndInstall(): void;
    /**
     * Sets the url and initialize the auto updater.
     */
    setFeedURL(options: FeedURLOptions): void;
  }

  interface BluetoothDevice {

    // Docs: http://electronjs.org/docs/api/structures/bluetooth-device

    deviceId: string;
    deviceName: string;
  }

  class BrowserView extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/browser-view

    constructor(options?: BrowserViewConstructorOptions);
    static fromId(id: number): BrowserView;
    static fromWebContents(webContents: WebContents): (BrowserView) | (null);
    static getAllViews(): BrowserView[];
    /**
     * Force closing the view, the unload and beforeunload events won't be emitted for
     * the web page. After you're done with a view, call this function in order to free
     * memory and other resources as soon as possible.
     */
    destroy(): void;
    isDestroyed(): boolean;
    setAutoResize(options: AutoResizeOptions): void;
    setBackgroundColor(color: string): void;
    /**
     * Resizes and moves the view to the supplied bounds relative to the window.
     */
    setBounds(bounds: Rectangle): void;
    id: number;
    webContents: WebContents;
  }

  class BrowserWindow extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/browser-window

    /**
     * Emitted when the window is set or unset to show always on top of other windows.
     */
    on(event: 'always-on-top-changed', listener: (event: Event,
                                                  isAlwaysOnTop: boolean) => void): this;
    once(event: 'always-on-top-changed', listener: (event: Event,
                                                  isAlwaysOnTop: boolean) => void): this;
    addListener(event: 'always-on-top-changed', listener: (event: Event,
                                                  isAlwaysOnTop: boolean) => void): this;
    removeListener(event: 'always-on-top-changed', listener: (event: Event,
                                                  isAlwaysOnTop: boolean) => void): this;
    /**
     * Emitted when an App Command is invoked. These are typically related to keyboard
     * media keys or browser commands, as well as the "Back" button built into some
     * mice on Windows. Commands are lowercased, underscores are replaced with hyphens,
     * and the APPCOMMAND_ prefix is stripped off. e.g. APPCOMMAND_BROWSER_BACKWARD is
     * emitted as browser-backward. The following app commands are explictly supported
     * on Linux:
     */
    on(event: 'app-command', listener: (event: Event,
                                        command: string) => void): this;
    once(event: 'app-command', listener: (event: Event,
                                        command: string) => void): this;
    addListener(event: 'app-command', listener: (event: Event,
                                        command: string) => void): this;
    removeListener(event: 'app-command', listener: (event: Event,
                                        command: string) => void): this;
    /**
     * Emitted when the window loses focus.
     */
    on(event: 'blur', listener: Function): this;
    once(event: 'blur', listener: Function): this;
    addListener(event: 'blur', listener: Function): this;
    removeListener(event: 'blur', listener: Function): this;
    /**
     * Emitted when the window is going to be closed. It's emitted before the
     * beforeunload and unload event of the DOM. Calling event.preventDefault() will
     * cancel the close. Usually you would want to use the beforeunload handler to
     * decide whether the window should be closed, which will also be called when the
     * window is reloaded. In Electron, returning any value other than undefined would
     * cancel the close. For example: Note: There is a subtle difference between the
     * behaviors of window.onbeforeunload = handler and
     * window.addEventListener('beforeunload', handler). It is recommended to always
     * set the event.returnValue explicitly, instead of only returning a value, as the
     * former works more consistently within Electron.
     */
    on(event: 'close', listener: (event: Event) => void): this;
    once(event: 'close', listener: (event: Event) => void): this;
    addListener(event: 'close', listener: (event: Event) => void): this;
    removeListener(event: 'close', listener: (event: Event) => void): this;
    /**
     * Emitted when the window is closed. After you have received this event you should
     * remove the reference to the window and avoid using it any more.
     */
    on(event: 'closed', listener: Function): this;
    once(event: 'closed', listener: Function): this;
    addListener(event: 'closed', listener: Function): this;
    removeListener(event: 'closed', listener: Function): this;
    /**
     * Emitted when the window enters a full-screen state.
     */
    on(event: 'enter-full-screen', listener: Function): this;
    once(event: 'enter-full-screen', listener: Function): this;
    addListener(event: 'enter-full-screen', listener: Function): this;
    removeListener(event: 'enter-full-screen', listener: Function): this;
    /**
     * Emitted when the window enters a full-screen state triggered by HTML API.
     */
    on(event: 'enter-html-full-screen', listener: Function): this;
    once(event: 'enter-html-full-screen', listener: Function): this;
    addListener(event: 'enter-html-full-screen', listener: Function): this;
    removeListener(event: 'enter-html-full-screen', listener: Function): this;
    /**
     * Emitted when the window gains focus.
     */
    on(event: 'focus', listener: Function): this;
    once(event: 'focus', listener: Function): this;
    addListener(event: 'focus', listener: Function): this;
    removeListener(event: 'focus', listener: Function): this;
    /**
     * Emitted when the window is hidden.
     */
    on(event: 'hide', listener: Function): this;
    once(event: 'hide', listener: Function): this;
    addListener(event: 'hide', listener: Function): this;
    removeListener(event: 'hide', listener: Function): this;
    /**
     * Emitted when the window leaves a full-screen state.
     */
    on(event: 'leave-full-screen', listener: Function): this;
    once(event: 'leave-full-screen', listener: Function): this;
    addListener(event: 'leave-full-screen', listener: Function): this;
    removeListener(event: 'leave-full-screen', listener: Function): this;
    /**
     * Emitted when the window leaves a full-screen state triggered by HTML API.
     */
    on(event: 'leave-html-full-screen', listener: Function): this;
    once(event: 'leave-html-full-screen', listener: Function): this;
    addListener(event: 'leave-html-full-screen', listener: Function): this;
    removeListener(event: 'leave-html-full-screen', listener: Function): this;
    /**
     * Emitted when window is maximized.
     */
    on(event: 'maximize', listener: Function): this;
    once(event: 'maximize', listener: Function): this;
    addListener(event: 'maximize', listener: Function): this;
    removeListener(event: 'maximize', listener: Function): this;
    /**
     * Emitted when the window is minimized.
     */
    on(event: 'minimize', listener: Function): this;
    once(event: 'minimize', listener: Function): this;
    addListener(event: 'minimize', listener: Function): this;
    removeListener(event: 'minimize', listener: Function): this;
    /**
     * Emitted when the window is being moved to a new position. Note: On macOS this
     * event is an alias of moved.
     */
    on(event: 'move', listener: Function): this;
    once(event: 'move', listener: Function): this;
    addListener(event: 'move', listener: Function): this;
    removeListener(event: 'move', listener: Function): this;
    /**
     * Emitted once when the window is moved to a new position.
     */
    on(event: 'moved', listener: Function): this;
    once(event: 'moved', listener: Function): this;
    addListener(event: 'moved', listener: Function): this;
    removeListener(event: 'moved', listener: Function): this;
    /**
     * Emitted when the native new tab button is clicked.
     */
    on(event: 'new-window-for-tab', listener: Function): this;
    once(event: 'new-window-for-tab', listener: Function): this;
    addListener(event: 'new-window-for-tab', listener: Function): this;
    removeListener(event: 'new-window-for-tab', listener: Function): this;
    /**
     * Emitted when the document changed its title, calling event.preventDefault() will
     * prevent the native window's title from changing. explicitSet is false when title
     * is synthesized from file url.
     */
    on(event: 'page-title-updated', listener: (event: Event,
                                               title: string,
                                               explicitSet: boolean) => void): this;
    once(event: 'page-title-updated', listener: (event: Event,
                                               title: string,
                                               explicitSet: boolean) => void): this;
    addListener(event: 'page-title-updated', listener: (event: Event,
                                               title: string,
                                               explicitSet: boolean) => void): this;
    removeListener(event: 'page-title-updated', listener: (event: Event,
                                               title: string,
                                               explicitSet: boolean) => void): this;
    /**
     * Emitted when the web page has been rendered (while not being shown) and window
     * can be displayed without a visual flash.
     */
    on(event: 'ready-to-show', listener: Function): this;
    once(event: 'ready-to-show', listener: Function): this;
    addListener(event: 'ready-to-show', listener: Function): this;
    removeListener(event: 'ready-to-show', listener: Function): this;
    /**
     * Emitted after the window has been resized.
     */
    on(event: 'resize', listener: Function): this;
    once(event: 'resize', listener: Function): this;
    addListener(event: 'resize', listener: Function): this;
    removeListener(event: 'resize', listener: Function): this;
    /**
     * Emitted when the unresponsive web page becomes responsive again.
     */
    on(event: 'responsive', listener: Function): this;
    once(event: 'responsive', listener: Function): this;
    addListener(event: 'responsive', listener: Function): this;
    removeListener(event: 'responsive', listener: Function): this;
    /**
     * Emitted when the window is restored from a minimized state.
     */
    on(event: 'restore', listener: Function): this;
    once(event: 'restore', listener: Function): this;
    addListener(event: 'restore', listener: Function): this;
    removeListener(event: 'restore', listener: Function): this;
    /**
     * Emitted when scroll wheel event phase has begun.
     */
    on(event: 'scroll-touch-begin', listener: Function): this;
    once(event: 'scroll-touch-begin', listener: Function): this;
    addListener(event: 'scroll-touch-begin', listener: Function): this;
    removeListener(event: 'scroll-touch-begin', listener: Function): this;
    /**
     * Emitted when scroll wheel event phase filed upon reaching the edge of element.
     */
    on(event: 'scroll-touch-edge', listener: Function): this;
    once(event: 'scroll-touch-edge', listener: Function): this;
    addListener(event: 'scroll-touch-edge', listener: Function): this;
    removeListener(event: 'scroll-touch-edge', listener: Function): this;
    /**
     * Emitted when scroll wheel event phase has ended.
     */
    on(event: 'scroll-touch-end', listener: Function): this;
    once(event: 'scroll-touch-end', listener: Function): this;
    addListener(event: 'scroll-touch-end', listener: Function): this;
    removeListener(event: 'scroll-touch-end', listener: Function): this;
    /**
     * Emitted when window session is going to end due to force shutdown or machine
     * restart or session log off.
     */
    on(event: 'session-end', listener: Function): this;
    once(event: 'session-end', listener: Function): this;
    addListener(event: 'session-end', listener: Function): this;
    removeListener(event: 'session-end', listener: Function): this;
    /**
     * Emitted when the window opens a sheet.
     */
    on(event: 'sheet-begin', listener: Function): this;
    once(event: 'sheet-begin', listener: Function): this;
    addListener(event: 'sheet-begin', listener: Function): this;
    removeListener(event: 'sheet-begin', listener: Function): this;
    /**
     * Emitted when the window has closed a sheet.
     */
    on(event: 'sheet-end', listener: Function): this;
    once(event: 'sheet-end', listener: Function): this;
    addListener(event: 'sheet-end', listener: Function): this;
    removeListener(event: 'sheet-end', listener: Function): this;
    /**
     * Emitted when the window is shown.
     */
    on(event: 'show', listener: Function): this;
    once(event: 'show', listener: Function): this;
    addListener(event: 'show', listener: Function): this;
    removeListener(event: 'show', listener: Function): this;
    /**
     * Emitted on 3-finger swipe. Possible directions are up, right, down, left.
     */
    on(event: 'swipe', listener: (event: Event,
                                  direction: string) => void): this;
    once(event: 'swipe', listener: (event: Event,
                                  direction: string) => void): this;
    addListener(event: 'swipe', listener: (event: Event,
                                  direction: string) => void): this;
    removeListener(event: 'swipe', listener: (event: Event,
                                  direction: string) => void): this;
    /**
     * Emitted when the window exits from a maximized state.
     */
    on(event: 'unmaximize', listener: Function): this;
    once(event: 'unmaximize', listener: Function): this;
    addListener(event: 'unmaximize', listener: Function): this;
    removeListener(event: 'unmaximize', listener: Function): this;
    /**
     * Emitted when the web page becomes unresponsive.
     */
    on(event: 'unresponsive', listener: Function): this;
    once(event: 'unresponsive', listener: Function): this;
    addListener(event: 'unresponsive', listener: Function): this;
    removeListener(event: 'unresponsive', listener: Function): this;
    /**
     * Emitted before the window is moved. Calling event.preventDefault() will prevent
     * the window from being moved. Note that this is only emitted when the window is
     * being resized manually. Resizing the window with setBounds/setSize will not emit
     * this event.
     */
    on(event: 'will-move', listener: (event: Event,
                                      /**
                                       * ` Location the window is being moved to.
                                       */
                                      newBounds: Rectangle) => void): this;
    once(event: 'will-move', listener: (event: Event,
                                      /**
                                       * ` Location the window is being moved to.
                                       */
                                      newBounds: Rectangle) => void): this;
    addListener(event: 'will-move', listener: (event: Event,
                                      /**
                                       * ` Location the window is being moved to.
                                       */
                                      newBounds: Rectangle) => void): this;
    removeListener(event: 'will-move', listener: (event: Event,
                                      /**
                                       * ` Location the window is being moved to.
                                       */
                                      newBounds: Rectangle) => void): this;
    /**
     * Emitted before the window is resized. Calling event.preventDefault() will
     * prevent the window from being resized. Note that this is only emitted when the
     * window is being resized manually. Resizing the window with setBounds/setSize
     * will not emit this event.
     */
    on(event: 'will-resize', listener: (event: Event,
                                        /**
                                         * ` Size the window is being resized to.
                                         */
                                        newBounds: Rectangle) => void): this;
    once(event: 'will-resize', listener: (event: Event,
                                        /**
                                         * ` Size the window is being resized to.
                                         */
                                        newBounds: Rectangle) => void): this;
    addListener(event: 'will-resize', listener: (event: Event,
                                        /**
                                         * ` Size the window is being resized to.
                                         */
                                        newBounds: Rectangle) => void): this;
    removeListener(event: 'will-resize', listener: (event: Event,
                                        /**
                                         * ` Size the window is being resized to.
                                         */
                                        newBounds: Rectangle) => void): this;
    constructor(options?: BrowserWindowConstructorOptions);
    /**
     * Adds DevTools extension located at path, and returns extension's name. The
     * extension will be remembered so you only need to call this API once, this API is
     * not for programming use. If you try to add an extension that has already been
     * loaded, this method will not return and instead log a warning to the console.
     * The method will also not return if the extension's manifest is missing or
     * incomplete. Note: This API cannot be called before the ready event of the app
     * module is emitted.
     */
    static addDevToolsExtension(path: string): void;
    /**
     * Adds Chrome extension located at path, and returns extension's name. The method
     * will also not return if the extension's manifest is missing or incomplete. Note:
     * This API cannot be called before the ready event of the app module is emitted.
     */
    static addExtension(path: string): void;
    static fromBrowserView(browserView: BrowserView): (BrowserWindow) | (null);
    static fromId(id: number): BrowserWindow;
    static fromWebContents(webContents: WebContents): BrowserWindow;
    static getAllWindows(): BrowserWindow[];
    /**
     * To check if a DevTools extension is installed you can run the following: Note:
     * This API cannot be called before the ready event of the app module is emitted.
     */
    static getDevToolsExtensions(): DevToolsExtensions;
    /**
     * Note: This API cannot be called before the ready event of the app module is
     * emitted.
     */
    static getExtensions(): Extensions;
    static getFocusedWindow(): (BrowserWindow) | (null);
    /**
     * Remove a DevTools extension by name. Note: This API cannot be called before the
     * ready event of the app module is emitted.
     */
    static removeDevToolsExtension(name: string): void;
    /**
     * Remove a Chrome extension by name. Note: This API cannot be called before the
     * ready event of the app module is emitted.
     */
    static removeExtension(name: string): void;
    /**
     * Replacement API for setBrowserView supporting work with multi browser views.
     */
    addBrowserView(browserView: BrowserView): void;
    /**
     * Adds a window as a tab on this window, after the tab for the window instance.
     */
    addTabbedWindow(browserWindow: BrowserWindow): void;
    /**
     * Removes focus from the window.
     */
    blur(): void;
    blurWebView(): void;
    /**
     * Captures a snapshot of the page within rect. Upon completion callback will be
     * called with callback(image). The image is an instance of NativeImage that stores
     * data of the snapshot. Omitting rect will capture the whole visible page.
     * Deprecated Soon
     */
    capturePage(callback: (image: NativeImage) => void): void;
    /**
     * Captures a snapshot of the page within rect. Omitting rect will capture the
     * whole visible page.
     */
    capturePage(rect?: Rectangle): Promise<Electron.NativeImage>;
    /**
     * Captures a snapshot of the page within rect. Upon completion callback will be
     * called with callback(image). The image is an instance of NativeImage that stores
     * data of the snapshot. Omitting rect will capture the whole visible page.
     * Deprecated Soon
     */
    capturePage(rect: Rectangle, callback: (image: NativeImage) => void): void;
    /**
     * Moves window to the center of the screen.
     */
    center(): void;
    /**
     * Try to close the window. This has the same effect as a user manually clicking
     * the close button of the window. The web page may cancel the close though. See
     * the close event.
     */
    close(): void;
    /**
     * Closes the currently open Quick Look panel.
     */
    closeFilePreview(): void;
    /**
     * Force closing the window, the unload and beforeunload event won't be emitted for
     * the web page, and close event will also not be emitted for this window, but it
     * guarantees the closed event will be emitted.
     */
    destroy(): void;
    /**
     * Starts or stops flashing the window to attract user's attention.
     */
    flashFrame(flag: boolean): void;
    /**
     * Focuses on the window.
     */
    focus(): void;
    focusOnWebView(): void;
    getBounds(): Rectangle;
    getBrowserView(): (BrowserView) | (null);
    /**
     * Returns array of BrowserView what was an attached with addBrowserView or
     * setBrowserView. Note: The BrowserView API is currently experimental and may
     * change or be removed in future Electron releases.
     */
    getBrowserViews(): void;
    getChildWindows(): BrowserWindow[];
    getContentBounds(): Rectangle;
    getContentSize(): number[];
    getMaximumSize(): number[];
    getMinimumSize(): number[];
    /**
     * The native type of the handle is HWND on Windows, NSView* on macOS, and Window
     * (unsigned long) on Linux.
     */
    getNativeWindowHandle(): Buffer;
    /**
     * Note: whatever the current state of the window : maximized, minimized or in
     * fullscreen, this function always returns the position and size of the window in
     * normal state. In normal state, getBounds and getNormalBounds returns the same
     * Rectangle.
     */
    getNormalBounds(): Rectangle;
    getOpacity(): number;
    getParentWindow(): BrowserWindow;
    getPosition(): number[];
    getRepresentedFilename(): string;
    getSize(): number[];
    /**
     * Note: The title of the web page can be different from the title of the native
     * window.
     */
    getTitle(): string;
    hasShadow(): boolean;
    /**
     * Hides the window.
     */
    hide(): void;
    /**
     * Hooks a windows message. The callback is called when the message is received in
     * the WndProc.
     */
    hookWindowMessage(message: number, callback: Function): void;
    isAlwaysOnTop(): boolean;
    /**
     * On Linux always returns true.
     */
    isClosable(): boolean;
    isDestroyed(): boolean;
    isDocumentEdited(): boolean;
    isFocused(): boolean;
    isFullScreen(): boolean;
    isFullScreenable(): boolean;
    isKiosk(): boolean;
    /**
     * On Linux always returns true.
     */
    isMaximizable(): boolean;
    isMaximized(): boolean;
    isMenuBarAutoHide(): boolean;
    isMenuBarVisible(): boolean;
    /**
     * On Linux always returns true.
     */
    isMinimizable(): boolean;
    isMinimized(): boolean;
    isModal(): boolean;
    /**
     * On Linux always returns true.
     */
    isMovable(): boolean;
    isNormal(): boolean;
    isResizable(): boolean;
    isSimpleFullScreen(): boolean;
    isVisible(): boolean;
    /**
     * Note: This API always returns false on Windows.
     */
    isVisibleOnAllWorkspaces(): boolean;
    isWindowMessageHooked(message: number): boolean;
    /**
     * Same as webContents.loadFile, filePath should be a path to an HTML file relative
     * to the root of your application.  See the webContents docs for more information.
     */
    loadFile(filePath: string, options?: LoadFileOptions): Promise<void>;
    /**
     * Same as webContents.loadURL(url[, options]). The url can be a remote address
     * (e.g. http://) or a path to a local HTML file using the file:// protocol. To
     * ensure that file URLs are properly formatted, it is recommended to use Node's
     * url.format method: You can load a URL using a POST request with URL-encoded data
     * by doing the following:
     */
    loadURL(url: string, options?: LoadURLOptions): Promise<void>;
    /**
     * Maximizes the window. This will also show (but not focus) the window if it isn't
     * being displayed already.
     */
    maximize(): void;
    /**
     * Merges all windows into one window with multiple tabs when native tabs are
     * enabled and there is more than one open window.
     */
    mergeAllWindows(): void;
    /**
     * Minimizes the window. On some platforms the minimized window will be shown in
     * the Dock.
     */
    minimize(): void;
    /**
     * Moves the current tab into a new window if native tabs are enabled and there is
     * more than one tab in the current window.
     */
    moveTabToNewWindow(): void;
    /**
     * Moves window to top(z-order) regardless of focus
     */
    moveTop(): void;
    /**
     * Uses Quick Look to preview a file at a given path.
     */
    previewFile(path: string, displayName?: string): void;
    /**
     * Same as webContents.reload.
     */
    reload(): void;
    removeBrowserView(browserView: BrowserView): void;
    /**
     * Remove the window's menu bar.
     */
    removeMenu(): void;
    /**
     * Restores the window from minimized state to its previous state.
     */
    restore(): void;
    /**
     * Selects the next tab when native tabs are enabled and there are other tabs in
     * the window.
     */
    selectNextTab(): void;
    /**
     * Selects the previous tab when native tabs are enabled and there are other tabs
     * in the window.
     */
    selectPreviousTab(): void;
    /**
     * Sets whether the window should show always on top of other windows. After
     * setting this, the window is still a normal window, not a toolbox window which
     * can not be focused on.
     */
    setAlwaysOnTop(flag: boolean, level?: 'normal' | 'floating' | 'torn-off-menu' | 'modal-panel' | 'main-menu' | 'status' | 'pop-up-menu' | 'screen-saver', relativeLevel?: number): void;
    /**
     * Sets the properties for the window's taskbar button. Note: relaunchCommand and
     * relaunchDisplayName must always be set together. If one of those properties is
     * not set, then neither will be used.
     */
    setAppDetails(options: AppDetailsOptions): void;
    /**
     * This will make a window maintain an aspect ratio. The extra size allows a
     * developer to have space, specified in pixels, not included within the aspect
     * ratio calculations. This API already takes into account the difference between a
     * window's size and its content size. Consider a normal window with an HD video
     * player and associated controls. Perhaps there are 15 pixels of controls on the
     * left edge, 25 pixels of controls on the right edge and 50 pixels of controls
     * below the player. In order to maintain a 16:9 aspect ratio (standard aspect
     * ratio for HD @1920x1080) within the player itself we would call this function
     * with arguments of 16/9 and [ 40, 50 ]. The second argument doesn't care where
     * the extra width and height are within the content view--only that they exist.
     * Sum any extra width and height areas you have within the overall content view.
     * Calling this function with a value of 0 will remove any previously set aspect
     * ratios.
     */
    setAspectRatio(aspectRatio: number, extraSize: Size): void;
    /**
     * Controls whether to hide cursor when typing.
     */
    setAutoHideCursor(autoHide: boolean): void;
    /**
     * Sets whether the window menu bar should hide itself automatically. Once set the
     * menu bar will only show when users press the single Alt key. If the menu bar is
     * already visible, calling setAutoHideMenuBar(true) won't hide it immediately.
     */
    setAutoHideMenuBar(hide: boolean): void;
    /**
     * Sets the background color of the window. See Setting backgroundColor.
     */
    setBackgroundColor(backgroundColor: string): void;
    /**
     * Resizes and moves the window to the supplied bounds. Any properties that are not
     * supplied will default to their current values.
     */
    setBounds(bounds: Rectangle, animate?: boolean): void;
    setBrowserView(browserView: BrowserView): void;
    /**
     * Sets whether the window can be manually closed by user. On Linux does nothing.
     */
    setClosable(closable: boolean): void;
    /**
     * Resizes and moves the window's client area (e.g. the web page) to the supplied
     * bounds.
     */
    setContentBounds(bounds: Rectangle, animate?: boolean): void;
    /**
     * Prevents the window contents from being captured by other apps. On macOS it sets
     * the NSWindow's sharingType to NSWindowSharingNone. On Windows it calls
     * SetWindowDisplayAffinity with WDA_MONITOR.
     */
    setContentProtection(enable: boolean): void;
    /**
     * Resizes the window's client area (e.g. the web page) to width and height.
     */
    setContentSize(width: number, height: number, animate?: boolean): void;
    /**
     * Specifies whether the window’s document has been edited, and the icon in title
     * bar will become gray when set to true.
     */
    setDocumentEdited(edited: boolean): void;
    /**
     * Disable or enable the window.
     */
    setEnabled(enable: boolean): void;
    /**
     * Changes whether the window can be focused.
     */
    setFocusable(focusable: boolean): void;
    /**
     * Sets whether the window should be in fullscreen mode.
     */
    setFullScreen(flag: boolean): void;
    /**
     * Sets whether the maximize/zoom window button toggles fullscreen mode or
     * maximizes the window.
     */
    setFullScreenable(fullscreenable: boolean): void;
    /**
     * Sets whether the window should have a shadow.
     */
    setHasShadow(hasShadow: boolean): void;
    /**
     * Changes window icon.
     */
    setIcon(icon: NativeImage): void;
    /**
     * Makes the window ignore all mouse events. All mouse events happened in this
     * window will be passed to the window below this window, but if this window has
     * focus, it will still receive keyboard events.
     */
    setIgnoreMouseEvents(ignore: boolean, options?: IgnoreMouseEventsOptions): void;
    /**
     * Enters or leaves the kiosk mode.
     */
    setKiosk(flag: boolean): void;
    /**
     * Sets whether the window can be manually maximized by user. On Linux does
     * nothing.
     */
    setMaximizable(maximizable: boolean): void;
    /**
     * Sets the maximum size of window to width and height.
     */
    setMaximumSize(width: number, height: number): void;
    /**
     * Sets the menu as the window's menu bar.
     */
    setMenu(menu: (Menu) | (null)): void;
    /**
     * Sets whether the menu bar should be visible. If the menu bar is auto-hide, users
     * can still bring up the menu bar by pressing the single Alt key.
     */
    setMenuBarVisibility(visible: boolean): void;
    /**
     * Sets whether the window can be manually minimized by user. On Linux does
     * nothing.
     */
    setMinimizable(minimizable: boolean): void;
    /**
     * Sets the minimum size of window to width and height.
     */
    setMinimumSize(width: number, height: number): void;
    /**
     * Sets whether the window can be moved by user. On Linux does nothing.
     */
    setMovable(movable: boolean): void;
    /**
     * Sets the opacity of the window. On Linux does nothing.
     */
    setOpacity(opacity: number): void;
    /**
     * Sets a 16 x 16 pixel overlay onto the current taskbar icon, usually used to
     * convey some sort of application status or to passively notify the user.
     */
    setOverlayIcon(overlay: (NativeImage) | (null), description: string): void;
    /**
     * Sets parent as current window's parent window, passing null will turn current
     * window into a top-level window.
     */
    setParentWindow(parent: BrowserWindow): void;
    /**
     * Moves window to x and y.
     */
    setPosition(x: number, y: number, animate?: boolean): void;
    /**
     * Sets progress value in progress bar. Valid range is [0, 1.0]. Remove progress
     * bar when progress < 0; Change to indeterminate mode when progress > 1. On Linux
     * platform, only supports Unity desktop environment, you need to specify the
     * *.desktop file name to desktopName field in package.json. By default, it will
     * assume app.getName().desktop. On Windows, a mode can be passed. Accepted values
     * are none, normal, indeterminate, error, and paused. If you call setProgressBar
     * without a mode set (but with a value within the valid range), normal will be
     * assumed.
     */
    setProgressBar(progress: number, options?: ProgressBarOptions): void;
    /**
     * Sets the pathname of the file the window represents, and the icon of the file
     * will show in window's title bar.
     */
    setRepresentedFilename(filename: string): void;
    /**
     * Sets whether the window can be manually resized by user.
     */
    setResizable(resizable: boolean): void;
    /**
     * Setting a window shape determines the area within the window where the system
     * permits drawing and user interaction. Outside of the given region, no pixels
     * will be drawn and no mouse events will be registered. Mouse events outside of
     * the region will not be received by that window, but will fall through to
     * whatever is behind the window.
     */
    setShape(rects: Rectangle[]): void;
    /**
     * Changes the attachment point for sheets on macOS. By default, sheets are
     * attached just below the window frame, but you may want to display them beneath a
     * HTML-rendered toolbar. For example:
     */
    setSheetOffset(offsetY: number, offsetX?: number): void;
    /**
     * Enters or leaves simple fullscreen mode. Simple fullscreen mode emulates the
     * native fullscreen behavior found in versions of Mac OS X prior to Lion (10.7).
     */
    setSimpleFullScreen(flag: boolean): void;
    /**
     * Resizes the window to width and height. If width or height are below any set
     * minimum size constraints the window will snap to its minimum size.
     */
    setSize(width: number, height: number, animate?: boolean): void;
    /**
     * Makes the window not show in the taskbar.
     */
    setSkipTaskbar(skip: boolean): void;
    /**
     * Add a thumbnail toolbar with a specified set of buttons to the thumbnail image
     * of a window in a taskbar button layout. Returns a Boolean object indicates
     * whether the thumbnail has been added successfully. The number of buttons in
     * thumbnail toolbar should be no greater than 7 due to the limited room. Once you
     * setup the thumbnail toolbar, the toolbar cannot be removed due to the platform's
     * limitation. But you can call the API with an empty array to clean the buttons.
     * The buttons is an array of Button objects: The flags is an array that can
     * include following Strings:
     */
    setThumbarButtons(buttons: ThumbarButton[]): boolean;
    /**
     * Sets the region of the window to show as the thumbnail image displayed when
     * hovering over the window in the taskbar. You can reset the thumbnail to be the
     * entire window by specifying an empty region: { x: 0, y: 0, width: 0, height: 0
     * }.
     */
    setThumbnailClip(region: Rectangle): void;
    /**
     * Sets the toolTip that is displayed when hovering over the window thumbnail in
     * the taskbar.
     */
    setThumbnailToolTip(toolTip: string): void;
    /**
     * Changes the title of native window to title.
     */
    setTitle(title: string): void;
    /**
     * Sets the touchBar layout for the current window. Specifying null or undefined
     * clears the touch bar. This method only has an effect if the machine has a touch
     * bar and is running on macOS 10.12.1+. Note: The TouchBar API is currently
     * experimental and may change or be removed in future Electron releases.
     */
    setTouchBar(touchBar: TouchBar): void;
    /**
     * Adds a vibrancy effect to the browser window. Passing null or an empty string
     * will remove the vibrancy effect on the window.
     */
    setVibrancy(type: 'appearance-based' | 'light' | 'dark' | 'titlebar' | 'selection' | 'menu' | 'popover' | 'sidebar' | 'medium-light' | 'ultra-dark'): void;
    /**
     * Sets whether the window should be visible on all workspaces. Note: This API does
     * nothing on Windows.
     */
    setVisibleOnAllWorkspaces(visible: boolean, options?: VisibleOnAllWorkspacesOptions): void;
    /**
     * Sets whether the window traffic light buttons should be visible. This cannot be
     * called when titleBarStyle is set to customButtonsOnHover.
     */
    setWindowButtonVisibility(visible: boolean): void;
    /**
     * Shows and gives focus to the window.
     */
    show(): void;
    /**
     * Same as webContents.showDefinitionForSelection().
     */
    showDefinitionForSelection(): void;
    /**
     * Shows the window but doesn't focus on it.
     */
    showInactive(): void;
    /**
     * Toggles the visibility of the tab bar if native tabs are enabled and there is
     * only one tab in the current window.
     */
    toggleTabBar(): void;
    /**
     * Unhooks all of the window messages.
     */
    unhookAllWindowMessages(): void;
    /**
     * Unhook the window message.
     */
    unhookWindowMessage(message: number): void;
    /**
     * Unmaximizes the window.
     */
    unmaximize(): void;
    id: number;
    webContents: WebContents;
  }

  class BrowserWindowProxy extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/browser-window-proxy

    /**
     * Removes focus from the child window.
     */
    blur(): void;
    /**
     * Forcefully closes the child window without calling its unload event.
     */
    close(): void;
    /**
     * Evaluates the code in the child window.
     */
    eval(code: string): void;
    /**
     * Focuses the child window (brings the window to front).
     */
    focus(): void;
    /**
     * Sends a message to the child window with the specified origin or * for no origin
     * preference. In addition to these methods, the child window implements
     * window.opener object with no properties and a single method.
     */
    postMessage(message: string, targetOrigin: string): void;
    /**
     * Invokes the print dialog on the child window.
     */
    print(): void;
    closed: boolean;
  }

  interface Certificate {

    // Docs: http://electronjs.org/docs/api/structures/certificate

    /**
     * PEM encoded data
     */
    data: string;
    /**
     * Fingerprint of the certificate
     */
    fingerprint: string;
    /**
     * Issuer principal
     */
    issuer: CertificatePrincipal;
    /**
     * Issuer certificate (if not self-signed)
     */
    issuerCert: Certificate;
    /**
     * Issuer's Common Name
     */
    issuerName: string;
    /**
     * Hex value represented string
     */
    serialNumber: string;
    /**
     * Subject principal
     */
    subject: CertificatePrincipal;
    /**
     * Subject's Common Name
     */
    subjectName: string;
    /**
     * End date of the certificate being valid in seconds
     */
    validExpiry: number;
    /**
     * Start date of the certificate being valid in seconds
     */
    validStart: number;
  }

  interface CertificatePrincipal {

    // Docs: http://electronjs.org/docs/api/structures/certificate-principal

    /**
     * Common Name.
     */
    commonName: string;
    /**
     * Country or region.
     */
    country: string;
    /**
     * Locality.
     */
    locality: string;
    /**
     * Organization names.
     */
    organizations: string[];
    /**
     * Organization Unit names.
     */
    organizationUnits: string[];
    /**
     * State or province.
     */
    state: string;
  }

  class ClientRequest extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/client-request

    /**
     * Emitted when the request is aborted. The abort event will not be fired if the
     * request is already closed.
     */
    on(event: 'abort', listener: Function): this;
    once(event: 'abort', listener: Function): this;
    addListener(event: 'abort', listener: Function): this;
    removeListener(event: 'abort', listener: Function): this;
    /**
     * Emitted as the last event in the HTTP request-response transaction. The close
     * event indicates that no more events will be emitted on either the request or
     * response objects.
     */
    on(event: 'close', listener: Function): this;
    once(event: 'close', listener: Function): this;
    addListener(event: 'close', listener: Function): this;
    removeListener(event: 'close', listener: Function): this;
    /**
     * Emitted when the net module fails to issue a network request. Typically when the
     * request object emits an error event, a close event will subsequently follow and
     * no response object will be provided.
     */
    on(event: 'error', listener: (
                                  /**
                                   * an error object providing some information about the failure.
                                   */
                                  error: Error) => void): this;
    once(event: 'error', listener: (
                                  /**
                                   * an error object providing some information about the failure.
                                   */
                                  error: Error) => void): this;
    addListener(event: 'error', listener: (
                                  /**
                                   * an error object providing some information about the failure.
                                   */
                                  error: Error) => void): this;
    removeListener(event: 'error', listener: (
                                  /**
                                   * an error object providing some information about the failure.
                                   */
                                  error: Error) => void): this;
    /**
     * Emitted just after the last chunk of the request's data has been written into
     * the request object.
     */
    on(event: 'finish', listener: Function): this;
    once(event: 'finish', listener: Function): this;
    addListener(event: 'finish', listener: Function): this;
    removeListener(event: 'finish', listener: Function): this;
    /**
     * Emitted when an authenticating proxy is asking for user credentials. The
     * callback function is expected to be called back with user credentials: Providing
     * empty credentials will cancel the request and report an authentication error on
     * the response object:
     */
    on(event: 'login', listener: (authInfo: AuthInfo,
                                  callback: (username: string, password: string) => void) => void): this;
    once(event: 'login', listener: (authInfo: AuthInfo,
                                  callback: (username: string, password: string) => void) => void): this;
    addListener(event: 'login', listener: (authInfo: AuthInfo,
                                  callback: (username: string, password: string) => void) => void): this;
    removeListener(event: 'login', listener: (authInfo: AuthInfo,
                                  callback: (username: string, password: string) => void) => void): this;
    /**
     * Emitted when there is redirection and the mode is manual. Calling
     * request.followRedirect will continue with the redirection.
     */
    on(event: 'redirect', listener: (statusCode: number,
                                     method: string,
                                     redirectUrl: string,
                                     responseHeaders: any) => void): this;
    once(event: 'redirect', listener: (statusCode: number,
                                     method: string,
                                     redirectUrl: string,
                                     responseHeaders: any) => void): this;
    addListener(event: 'redirect', listener: (statusCode: number,
                                     method: string,
                                     redirectUrl: string,
                                     responseHeaders: any) => void): this;
    removeListener(event: 'redirect', listener: (statusCode: number,
                                     method: string,
                                     redirectUrl: string,
                                     responseHeaders: any) => void): this;
    on(event: 'response', listener: (
                                     /**
                                      * An object representing the HTTP response message.
                                      */
                                     response: IncomingMessage) => void): this;
    once(event: 'response', listener: (
                                     /**
                                      * An object representing the HTTP response message.
                                      */
                                     response: IncomingMessage) => void): this;
    addListener(event: 'response', listener: (
                                     /**
                                      * An object representing the HTTP response message.
                                      */
                                     response: IncomingMessage) => void): this;
    removeListener(event: 'response', listener: (
                                     /**
                                      * An object representing the HTTP response message.
                                      */
                                     response: IncomingMessage) => void): this;
    constructor(options: 'method' | 'url' | 'session' | 'partition' | 'protocol' | 'host' | 'hostname' | 'port' | 'path' | 'redirect');
    /**
     * Cancels an ongoing HTTP transaction. If the request has already emitted the
     * close event, the abort operation will have no effect. Otherwise an ongoing event
     * will emit abort and close events. Additionally, if there is an ongoing response
     * object,it will emit the aborted event.
     */
    abort(): void;
    /**
     * Sends the last chunk of the request data. Subsequent write or end operations
     * will not be allowed. The finish event is emitted just after the end operation.
     */
    end(chunk?: (string) | (Buffer), encoding?: string, callback?: Function): void;
    /**
     * Continues any deferred redirection request when the redirection mode is manual.
     */
    followRedirect(): void;
    getHeader(name: string): Header;
    /**
     * You can use this method in conjunction with POST requests to get the progress of
     * a file upload or other data transfer.
     */
    getUploadProgress(): UploadProgress;
    /**
     * Removes a previously set extra header name. This method can be called only
     * before first write. Trying to call it after the first write will throw an error.
     */
    removeHeader(name: string): void;
    /**
     * Adds an extra HTTP header. The header name will issued as it is without
     * lowercasing. It can be called only before first write. Calling this method after
     * the first write will throw an error. If the passed value is not a String, its
     * toString() method will be called to obtain the final value.
     */
    setHeader(name: string, value: any): void;
    /**
     * callback is essentially a dummy function introduced in the purpose of keeping
     * similarity with the Node.js API. It is called asynchronously in the next tick
     * after chunk content have been delivered to the Chromium networking layer.
     * Contrary to the Node.js implementation, it is not guaranteed that chunk content
     * have been flushed on the wire before callback is called. Adds a chunk of data to
     * the request body. The first write operation may cause the request headers to be
     * issued on the wire. After the first write operation, it is not allowed to add or
     * remove a custom header.
     */
    write(chunk: (string) | (Buffer), encoding?: string, callback?: Function): void;
    chunkedEncoding: boolean;
  }

  interface Clipboard extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/clipboard

    availableFormats(type?: 'selection' | 'clipboard'): string[];
    /**
     * Clears the clipboard content.
     */
    clear(type?: 'selection' | 'clipboard'): void;
    has(format: string, type?: 'selection' | 'clipboard'): boolean;
    read(format: string): string;
    /**
     * Returns an Object containing title and url keys representing the bookmark in the
     * clipboard. The title and url values will be empty strings when the bookmark is
     * unavailable.
     */
    readBookmark(): ReadBookmark;
    readBuffer(format: string): Buffer;
    /**
     * This method uses synchronous IPC when called from the renderer process. The
     * cached value is reread from the find pasteboard whenever the application is
     * activated.
     */
    readFindText(): string;
    readHTML(type?: 'selection' | 'clipboard'): string;
    readImage(type?: 'selection' | 'clipboard'): NativeImage;
    readRTF(type?: 'selection' | 'clipboard'): string;
    readText(type?: 'selection' | 'clipboard'): string;
    /**
     * Writes data to the clipboard.
     */
    write(data: Data, type?: 'selection' | 'clipboard'): void;
    /**
     * Writes the title and url into the clipboard as a bookmark. Note: Most apps on
     * Windows don't support pasting bookmarks into them so you can use clipboard.write
     * to write both a bookmark and fallback text to the clipboard.
     */
    writeBookmark(title: string, url: string, type?: 'selection' | 'clipboard'): void;
    /**
     * Writes the buffer into the clipboard as format.
     */
    writeBuffer(format: string, buffer: Buffer, type?: 'selection' | 'clipboard'): void;
    /**
     * Writes the text into the find pasteboard (the pasteboard that holds information
     * about the current state of the active application’s find panel) as plain text.
     * This method uses synchronous IPC when called from the renderer process.
     */
    writeFindText(text: string): void;
    /**
     * Writes markup to the clipboard.
     */
    writeHTML(markup: string, type?: 'selection' | 'clipboard'): void;
    /**
     * Writes image to the clipboard.
     */
    writeImage(image: NativeImage, type?: 'selection' | 'clipboard'): void;
    /**
     * Writes the text into the clipboard in RTF.
     */
    writeRTF(text: string, type?: 'selection' | 'clipboard'): void;
    /**
     * Writes the text into the clipboard as plain text.
     */
    writeText(text: string, type?: 'selection' | 'clipboard'): void;
  }

  interface ContentTracing extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/content-tracing

    /**
     * Get a set of category groups. The category groups can change as new code paths
     * are reached. Once all child processes have acknowledged the getCategories
     * request the callback is invoked with an array of category groups. Deprecated
     * Soon
     */
    getCategories(callback: (categories: string[]) => void): void;
    /**
     * Get a set of category groups. The category groups can change as new code paths
     * are reached.
     */
    getCategories(): Promise<string[]>;
    /**
     * Get the maximum usage across processes of trace buffer as a percentage of the
     * full state. When the TraceBufferUsage value is determined the callback is
     * called. Deprecated Soon
     */
    getTraceBufferUsage(callback: (value: number) => void): void;
    /**
     * Get the maximum usage across processes of trace buffer as a percentage of the
     * full state.
     */
    getTraceBufferUsage(): Promise<any>;
    /**
     * Start recording on all processes. Recording begins immediately locally and
     * asynchronously on child processes as soon as they receive the EnableRecording
     * request. The callback will be called once all child processes have acknowledged
     * the startRecording request. Deprecated Soon
     */
    startRecording(options: (TraceCategoriesAndOptions) | (TraceConfig), callback: Function): void;
    /**
     * Start recording on all processes. Recording begins immediately locally and
     * asynchronously on child processes as soon as they receive the EnableRecording
     * request.
     */
    startRecording(options: (TraceCategoriesAndOptions) | (TraceConfig)): Promise<void>;
    /**
     * Stop recording on all processes. Child processes typically cache trace data and
     * only rarely flush and send trace data back to the main process. This helps to
     * minimize the runtime overhead of tracing since sending trace data over IPC can
     * be an expensive operation. So, to end tracing, we must asynchronously ask all
     * child processes to flush any pending trace data. Once all child processes have
     * acknowledged the stopRecording request, callback will be called with a file that
     * contains the traced data. Trace data will be written into resultFilePath if it
     * is not empty or into a temporary file. The actual file path will be passed to
     * callback if it's not null. Deprecated Soon
     */
    stopRecording(resultFilePath: string, callback: (resultFilePath: string) => void): void;
    /**
     * Stop recording on all processes. Child processes typically cache trace data and
     * only rarely flush and send trace data back to the main process. This helps to
     * minimize the runtime overhead of tracing since sending trace data over IPC can
     * be an expensive operation. So, to end tracing, we must asynchronously ask all
     * child processes to flush any pending trace data. Trace data will be written into
     * resultFilePath if it is not empty or into a temporary file.
     */
    stopRecording(resultFilePath: string): Promise<string>;
  }

  interface ContextBridge extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/context-bridge

    exposeInMainWorld(apiKey: string, api: Record<string, any>): void;
  }

  interface Cookie {

    // Docs: http://electronjs.org/docs/api/structures/cookie

    /**
     * The domain of the cookie; this will be normalized with a preceding dot so that
     * it's also valid for subdomains.
     */
    domain?: string;
    /**
     * The expiration date of the cookie as the number of seconds since the UNIX epoch.
     * Not provided for session cookies.
     */
    expirationDate?: number;
    /**
     * Whether the cookie is a host-only cookie; this will only be true if no domain
     * was passed.
     */
    hostOnly?: boolean;
    /**
     * Whether the cookie is marked as HTTP only.
     */
    httpOnly?: boolean;
    /**
     * The name of the cookie.
     */
    name: string;
    /**
     * The path of the cookie.
     */
    path?: string;
    /**
     * Whether the cookie is marked as secure.
     */
    secure?: boolean;
    /**
     * Whether the cookie is a session cookie or a persistent cookie with an expiration
     * date.
     */
    session?: boolean;
    /**
     * The value of the cookie.
     */
    value: string;
  }

  class Cookies extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/cookies

    /**
     * Emitted when a cookie is changed because it was added, edited, removed, or
     * expired.
     */
    on(event: 'changed', listener: (event: Event,
                                    /**
                                     * The cookie that was changed.
                                     */
                                    cookie: Cookie,
                                    /**
                                     * The cause of the change with one of the following values:
                                     */
                                    cause: ('explicit' | 'overwrite' | 'expired' | 'evicted' | 'expired-overwrite'),
                                    /**
                                     * `true` if the cookie was removed, `false` otherwise.
                                     */
                                    removed: boolean) => void): this;
    once(event: 'changed', listener: (event: Event,
                                    /**
                                     * The cookie that was changed.
                                     */
                                    cookie: Cookie,
                                    /**
                                     * The cause of the change with one of the following values:
                                     */
                                    cause: ('explicit' | 'overwrite' | 'expired' | 'evicted' | 'expired-overwrite'),
                                    /**
                                     * `true` if the cookie was removed, `false` otherwise.
                                     */
                                    removed: boolean) => void): this;
    addListener(event: 'changed', listener: (event: Event,
                                    /**
                                     * The cookie that was changed.
                                     */
                                    cookie: Cookie,
                                    /**
                                     * The cause of the change with one of the following values:
                                     */
                                    cause: ('explicit' | 'overwrite' | 'expired' | 'evicted' | 'expired-overwrite'),
                                    /**
                                     * `true` if the cookie was removed, `false` otherwise.
                                     */
                                    removed: boolean) => void): this;
    removeListener(event: 'changed', listener: (event: Event,
                                    /**
                                     * The cookie that was changed.
                                     */
                                    cookie: Cookie,
                                    /**
                                     * The cause of the change with one of the following values:
                                     */
                                    cause: ('explicit' | 'overwrite' | 'expired' | 'evicted' | 'expired-overwrite'),
                                    /**
                                     * `true` if the cookie was removed, `false` otherwise.
                                     */
                                    removed: boolean) => void): this;
    /**
     * Writes any unwritten cookies data to disk.
     */
    flushStore(): Promise<void>;
    /**
     * Writes any unwritten cookies data to disk. Deprecated Soon
     */
    flushStore(callback: Function): void;
    /**
     * Sends a request to get all cookies matching filter, and resolves a promise with
     * the response.
     */
    get(filter: Filter): Promise<Electron.Cookie[]>;
    /**
     * Sends a request to get all cookies matching filter, callback will be called with
     * callback(error, cookies) on complete. Deprecated Soon
     */
    get(filter: Filter, callback: (error: Error, cookies: Cookie[]) => void): void;
    /**
     * Removes the cookies matching url and name
     */
    remove(url: string, name: string): Promise<void>;
    /**
     * Removes the cookies matching url and name, callback will called with callback()
     * on complete. Deprecated Soon
     */
    remove(url: string, name: string, callback: Function): void;
    /**
     * Sets a cookie with details.
     */
    set(details: Details): Promise<void>;
    /**
     * Sets a cookie with details, callback will be called with callback(error) on
     * complete. Deprecated Soon
     */
    set(details: Details, callback: (error: Error) => void): void;
  }

  interface CPUUsage {

    // Docs: http://electronjs.org/docs/api/structures/cpu-usage

    /**
     * The number of average idle cpu wakeups per second since the last call to
     * getCPUUsage. First call returns 0. Will always return 0 on Windows.
     */
    idleWakeupsPerSecond: number;
    /**
     * Percentage of CPU used since the last call to getCPUUsage. First call returns 0.
     */
    percentCPUUsage: number;
  }

  interface CrashReport {

    // Docs: http://electronjs.org/docs/api/structures/crash-report

    date: Date;
    id: string;
  }

  interface CrashReporter {

    // Docs: http://electronjs.org/docs/api/crash-reporter

    /**
     * Set an extra parameter to be sent with the crash report. The values specified
     * here will be sent in addition to any values set via the extra option when start
     * was called. This API is only available on macOS and windows, if you need to
     * add/update extra parameters on Linux after your first call to start you can call
     * start again with the updated extra options.
     */
    addExtraParameter(key: string, value: string): void;
    /**
     * Returns the date and ID of the last crash report. Only crash reports that have
     * been uploaded will be returned; even if a crash report is present on disk it
     * will not be returned until it is uploaded. In the case that there are no
     * uploaded reports, null is returned.
     */
    getLastCrashReport(): CrashReport;
    /**
     * See all of the current parameters being passed to the crash reporter.
     */
    getParameters(): void;
    /**
     * Returns all uploaded crash reports. Each report contains the date and uploaded
     * ID.
     */
    getUploadedReports(): CrashReport[];
    /**
     * Note: This API can only be called from the main process.
     */
    getUploadToServer(): boolean;
    /**
     * Remove a extra parameter from the current set of parameters so that it will not
     * be sent with the crash report.
     */
    removeExtraParameter(key: string): void;
    /**
     * This would normally be controlled by user preferences. This has no effect if
     * called before start is called. Note: This API can only be called from the main
     * process.
     */
    setUploadToServer(uploadToServer: boolean): void;
    /**
     * You are required to call this method before using any other crashReporter APIs
     * and in each process (main/renderer) from which you want to collect crash
     * reports. You can pass different options to crashReporter.start when calling from
     * different processes. Note Child processes created via the child_process module
     * will not have access to the Electron modules. Therefore, to collect crash
     * reports from them, use process.crashReporter.start instead. Pass the same
     * options as above along with an additional one called crashesDirectory that
     * should point to a directory to store the crash reports temporarily. You can test
     * this out by calling process.crash() to crash the child process. Note: If you
     * need send additional/updated extra parameters after your first call start you
     * can call addExtraParameter on macOS or call start again with the new/updated
     * extra parameters on Linux and Windows. Note: On macOS and windows, Electron uses
     * a new crashpad client for crash collection and reporting. If you want to enable
     * crash reporting, initializing crashpad from the main process using
     * crashReporter.start is required regardless of which process you want to collect
     * crashes from. Once initialized this way, the crashpad handler collects crashes
     * from all processes. You still have to call crashReporter.start from the renderer
     * or child process, otherwise crashes from them will get reported without
     * companyName, productName or any of the extra information.
     */
    start(options: CrashReporterStartOptions): void;
  }

  interface CustomScheme {

    // Docs: http://electronjs.org/docs/api/structures/custom-scheme

    privileges?: Privileges;
    /**
     * Custom schemes to be registered with options.
     */
    scheme: string;
  }

  class Debugger extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/debugger

    /**
     * Emitted when debugging session is terminated. This happens either when
     * webContents is closed or devtools is invoked for the attached webContents.
     */
    on(event: 'detach', listener: (event: Event,
                                   /**
                                    * Reason for detaching debugger.
                                    */
                                   reason: string) => void): this;
    once(event: 'detach', listener: (event: Event,
                                   /**
                                    * Reason for detaching debugger.
                                    */
                                   reason: string) => void): this;
    addListener(event: 'detach', listener: (event: Event,
                                   /**
                                    * Reason for detaching debugger.
                                    */
                                   reason: string) => void): this;
    removeListener(event: 'detach', listener: (event: Event,
                                   /**
                                    * Reason for detaching debugger.
                                    */
                                   reason: string) => void): this;
    /**
     * Emitted whenever debugging target issues instrumentation event.
     */
    on(event: 'message', listener: (event: Event,
                                    /**
                                     * Method name.
                                     */
                                    method: string,
                                    /**
                                     * Event parameters defined by the 'parameters' attribute in the remote debugging
                                     * protocol.
                                     */
                                    params: any) => void): this;
    once(event: 'message', listener: (event: Event,
                                    /**
                                     * Method name.
                                     */
                                    method: string,
                                    /**
                                     * Event parameters defined by the 'parameters' attribute in the remote debugging
                                     * protocol.
                                     */
                                    params: any) => void): this;
    addListener(event: 'message', listener: (event: Event,
                                    /**
                                     * Method name.
                                     */
                                    method: string,
                                    /**
                                     * Event parameters defined by the 'parameters' attribute in the remote debugging
                                     * protocol.
                                     */
                                    params: any) => void): this;
    removeListener(event: 'message', listener: (event: Event,
                                    /**
                                     * Method name.
                                     */
                                    method: string,
                                    /**
                                     * Event parameters defined by the 'parameters' attribute in the remote debugging
                                     * protocol.
                                     */
                                    params: any) => void): this;
    /**
     * Attaches the debugger to the webContents.
     */
    attach(protocolVersion?: string): void;
    /**
     * Detaches the debugger from the webContents.
     */
    detach(): void;
    isAttached(): boolean;
    /**
     * Send given command to the debugging target. Deprecated Soon
     */
    sendCommand(method: string, commandParams?: any, callback?: (error: any, result: any) => void): void;
    /**
     * Send given command to the debugging target.
     */
    sendCommand(method: string, commandParams?: any): Promise<any>;
  }

  interface DesktopCapturer extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/desktop-capturer

    /**
     * Starts gathering information about all available desktop media sources, and
     * calls callback(error, sources) when finished. sources is an array of
     * DesktopCapturerSource objects, each DesktopCapturerSource represents a screen or
     * an individual window that can be captured. Deprecated Soon
     */
    getSources(options: SourcesOptions, callback: (error: Error, sources: DesktopCapturerSource[]) => void): void;
    getSources(options: SourcesOptions): Promise<Electron.DesktopCapturerSource[]>;
  }

  interface DesktopCapturerSource {

    // Docs: http://electronjs.org/docs/api/structures/desktop-capturer-source

    /**
     * An icon image of the application that owns the window or null if the source has
     * a type screen. The size of the icon is not known in advance and depends on what
     * the the application provides.
     */
    appIcon: NativeImage;
    /**
     * A unique identifier that will correspond to the id of the matching returned by
     * the . On some platforms, this is equivalent to the XX portion of the id field
     * above and on others it will differ. It will be an empty string if not available.
     */
    display_id: string;
    /**
     * The identifier of a window or screen that can be used as a chromeMediaSourceId
     * constraint when calling [navigator.webkitGetUserMedia]. The format of the
     * identifier will be window:XX or screen:XX, where XX is a random generated
     * number.
     */
    id: string;
    /**
     * A screen source will be named either Entire Screen or Screen , while the name of
     * a window source will match the window title.
     */
    name: string;
    /**
     * A thumbnail image. There is no guarantee that the size of the thumbnail is the
     * same as the thumbnailSize specified in the options passed to
     * desktopCapturer.getSources. The actual size depends on the scale of the screen
     * or window.
     */
    thumbnail: NativeImage;
  }

  interface Dialog extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/dialog

    /**
     * On macOS, this displays a modal dialog that shows a message and certificate
     * information, and gives the user the option of trusting/importing the
     * certificate. If you provide a browserWindow argument the dialog will be attached
     * to the parent window, making it modal. On Windows the options are more limited,
     * due to the Win32 APIs used: Deprecated Soon
     */
    showCertificateTrustDialog(browserWindow: BrowserWindow, options: CertificateTrustDialogOptions, callback: Function): void;
    /**
     * On macOS, this displays a modal dialog that shows a message and certificate
     * information, and gives the user the option of trusting/importing the
     * certificate. If you provide a browserWindow argument the dialog will be attached
     * to the parent window, making it modal. On Windows the options are more limited,
     * due to the Win32 APIs used:
     */
    showCertificateTrustDialog(options: CertificateTrustDialogOptions): Promise<void>;
    /**
     * On macOS, this displays a modal dialog that shows a message and certificate
     * information, and gives the user the option of trusting/importing the
     * certificate. If you provide a browserWindow argument the dialog will be attached
     * to the parent window, making it modal. On Windows the options are more limited,
     * due to the Win32 APIs used: Deprecated Soon
     */
    showCertificateTrustDialog(options: CertificateTrustDialogOptions, callback: Function): void;
    /**
     * On macOS, this displays a modal dialog that shows a message and certificate
     * information, and gives the user the option of trusting/importing the
     * certificate. If you provide a browserWindow argument the dialog will be attached
     * to the parent window, making it modal. On Windows the options are more limited,
     * due to the Win32 APIs used:
     */
    showCertificateTrustDialog(browserWindow: BrowserWindow, options: CertificateTrustDialogOptions): Promise<void>;
    /**
     * On macOS, this displays a modal dialog that shows a message and certificate
     * information, and gives the user the option of trusting/importing the
     * certificate. If you provide a browserWindow argument the dialog will be attached
     * to the parent window, making it modal. On Windows the options are more limited,
     * due to the Win32 APIs used: Deprecated Soon
     */
    showCertificateTrustDialog(browserWindow: BrowserWindow, options: CertificateTrustDialogOptions, callback: Function): void;
    /**
     * Displays a modal dialog that shows an error message. This API can be called
     * safely before the ready event the app module emits, it is usually used to report
     * errors in early stage of startup. If called before the app readyevent on Linux,
     * the message will be emitted to stderr, and no GUI dialog will appear.
     */
    showErrorBox(title: string, content: string): void;
    /**
     * Shows a message box, it will block the process until the message box is closed.
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal.
     */
    showMessageBox(browserWindow: BrowserWindow, options: MessageBoxOptions): Promise<Electron.MessageBoxReturnValue>;
    /**
     * Shows a message box, it will block the process until the message box is closed.
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal.
     */
    showMessageBox(options: MessageBoxOptions): Promise<Electron.MessageBoxReturnValue>;
    /**
     * Shows a message box, it will block the process until the message box is closed.
     * It returns the index of the clicked button. The browserWindow argument allows
     * the dialog to attach itself to a parent window, making it modal.
     */
    showMessageBoxSync(browserWindow: BrowserWindow, options: MessageBoxSyncOptions): number;
    /**
     * Shows a message box, it will block the process until the message box is closed.
     * It returns the index of the clicked button. The browserWindow argument allows
     * the dialog to attach itself to a parent window, making it modal.
     */
    showMessageBoxSync(options: MessageBoxSyncOptions): number;
    /**
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal. The filters specifies an array of file types that can
     * be displayed or selected when you want to limit the user to a specific type. For
     * example: The extensions array should contain extensions without wildcards or
     * dots (e.g. 'png' is good but '.png' and '*.png' are bad). To show all files, use
     * the '*' wildcard (no other wildcard is supported). Note: On Windows and Linux an
     * open dialog can not be both a file selector and a directory selector, so if you
     * set properties to ['openFile', 'openDirectory'] on these platforms, a directory
     * selector will be shown.
     */
    showOpenDialog(browserWindow: BrowserWindow, options: OpenDialogOptions, callback?: Function): Promise<Electron.OpenDialogReturnValue>;
    /**
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal. The filters specifies an array of file types that can
     * be displayed or selected when you want to limit the user to a specific type. For
     * example: The extensions array should contain extensions without wildcards or
     * dots (e.g. 'png' is good but '.png' and '*.png' are bad). To show all files, use
     * the '*' wildcard (no other wildcard is supported). Note: On Windows and Linux an
     * open dialog can not be both a file selector and a directory selector, so if you
     * set properties to ['openFile', 'openDirectory'] on these platforms, a directory
     * selector will be shown.
     */
    showOpenDialog(options: OpenDialogOptions, callback?: Function): Promise<Electron.OpenDialogReturnValue>;
    /**
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal. The filters specifies an array of file types that can
     * be displayed or selected when you want to limit the user to a specific type. For
     * example: The extensions array should contain extensions without wildcards or
     * dots (e.g. 'png' is good but '.png' and '*.png' are bad). To show all files, use
     * the '*' wildcard (no other wildcard is supported). Note: On Windows and Linux an
     * open dialog can not be both a file selector and a directory selector, so if you
     * set properties to ['openFile', 'openDirectory'] on these platforms, a directory
     * selector will be shown.
     */
    showOpenDialogSync(browserWindow: BrowserWindow, options: OpenDialogSyncOptions): (string[]) | (undefined);
    /**
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal. The filters specifies an array of file types that can
     * be displayed or selected when you want to limit the user to a specific type. For
     * example: The extensions array should contain extensions without wildcards or
     * dots (e.g. 'png' is good but '.png' and '*.png' are bad). To show all files, use
     * the '*' wildcard (no other wildcard is supported). Note: On Windows and Linux an
     * open dialog can not be both a file selector and a directory selector, so if you
     * set properties to ['openFile', 'openDirectory'] on these platforms, a directory
     * selector will be shown.
     */
    showOpenDialogSync(options: OpenDialogSyncOptions): (string[]) | (undefined);
    /**
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal. The filters specifies an array of file types that can
     * be displayed, see dialog.showOpenDialog for an example. Note: On macOS, using
     * the asynchronous version is recommended to avoid issues when expanding and
     * collapsing the dialog.
     */
    showSaveDialog(options: SaveDialogOptions): Promise<Electron.SaveDialogReturnValue>;
    /**
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal. The filters specifies an array of file types that can
     * be displayed, see dialog.showOpenDialog for an example. Note: On macOS, using
     * the asynchronous version is recommended to avoid issues when expanding and
     * collapsing the dialog.
     */
    showSaveDialog(browserWindow: BrowserWindow, options: SaveDialogOptions): Promise<Electron.SaveDialogReturnValue>;
    /**
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal. The filters specifies an array of file types that can
     * be displayed, see dialog.showOpenDialog for an example.
     */
    showSaveDialogSync(options: SaveDialogSyncOptions): (string) | (undefined);
    /**
     * The browserWindow argument allows the dialog to attach itself to a parent
     * window, making it modal. The filters specifies an array of file types that can
     * be displayed, see dialog.showOpenDialog for an example.
     */
    showSaveDialogSync(browserWindow: BrowserWindow, options: SaveDialogSyncOptions): (string) | (undefined);
  }

  interface Display {

    // Docs: http://electronjs.org/docs/api/structures/display

    /**
     * Can be available, unavailable, unknown.
     */
    accelerometerSupport: ('available' | 'unavailable' | 'unknown');
    bounds: Rectangle;
    /**
     * The number of bits per pixel.
     */
    colorDepth: number;
    /**
     * represent a color space (three-dimensional object which contains all realizable
     * color combinations) for the purpose of color conversions
     */
    colorSpace: string;
    /**
     * The number of bits per color component.
     */
    depthPerComponent: number;
    /**
     * Unique identifier associated with the display.
     */
    id: number;
    /**
     * true for an internal display and false for an external display
     */
    internal: boolean;
    /**
     * Whether or not the display is a monochrome display.
     */
    monochrome: boolean;
    /**
     * Can be 0, 90, 180, 270, represents screen rotation in clock-wise degrees.
     */
    rotation: number;
    /**
     * Output device's pixel scale factor.
     */
    scaleFactor: number;
    size: Size;
    /**
     * Can be available, unavailable, unknown.
     */
    touchSupport: ('available' | 'unavailable' | 'unknown');
    workArea: Rectangle;
    workAreaSize: Size;
  }

  class DownloadItem extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/download-item

    /**
     * Emitted when the download is in a terminal state. This includes a completed
     * download, a cancelled download (via downloadItem.cancel()), and interrupted
     * download that can't be resumed. The state can be one of following:
     */
    on(event: 'done', listener: (event: Event,
                                 /**
                                  * Can be `completed`, `cancelled` or `interrupted`.
                                  */
                                 state: ('completed' | 'cancelled' | 'interrupted')) => void): this;
    once(event: 'done', listener: (event: Event,
                                 /**
                                  * Can be `completed`, `cancelled` or `interrupted`.
                                  */
                                 state: ('completed' | 'cancelled' | 'interrupted')) => void): this;
    addListener(event: 'done', listener: (event: Event,
                                 /**
                                  * Can be `completed`, `cancelled` or `interrupted`.
                                  */
                                 state: ('completed' | 'cancelled' | 'interrupted')) => void): this;
    removeListener(event: 'done', listener: (event: Event,
                                 /**
                                  * Can be `completed`, `cancelled` or `interrupted`.
                                  */
                                 state: ('completed' | 'cancelled' | 'interrupted')) => void): this;
    /**
     * Emitted when the download has been updated and is not done. The state can be one
     * of following:
     */
    on(event: 'updated', listener: (event: Event,
                                    /**
                                     * Can be `progressing` or `interrupted`.
                                     */
                                    state: ('progressing' | 'interrupted')) => void): this;
    once(event: 'updated', listener: (event: Event,
                                    /**
                                     * Can be `progressing` or `interrupted`.
                                     */
                                    state: ('progressing' | 'interrupted')) => void): this;
    addListener(event: 'updated', listener: (event: Event,
                                    /**
                                     * Can be `progressing` or `interrupted`.
                                     */
                                    state: ('progressing' | 'interrupted')) => void): this;
    removeListener(event: 'updated', listener: (event: Event,
                                    /**
                                     * Can be `progressing` or `interrupted`.
                                     */
                                    state: ('progressing' | 'interrupted')) => void): this;
    /**
     * Cancels the download operation.
     */
    cancel(): void;
    canResume(): boolean;
    getContentDisposition(): string;
    getETag(): string;
    /**
     * Note: The file name is not always the same as the actual one saved in local
     * disk. If user changes the file name in a prompted download saving dialog, the
     * actual name of saved file will be different.
     */
    getFilename(): string;
    getLastModifiedTime(): string;
    getMimeType(): string;
    getReceivedBytes(): number;
    getSaveDialogOptions(): SaveDialogOptions;
    getSavePath(): string;
    getStartTime(): number;
    /**
     * Note: The following methods are useful specifically to resume a cancelled item
     * when session is restarted.
     */
    getState(): ('progressing' | 'completed' | 'cancelled' | 'interrupted');
    /**
     * If the size is unknown, it returns 0.
     */
    getTotalBytes(): number;
    getURL(): string;
    getURLChain(): string[];
    hasUserGesture(): boolean;
    isPaused(): boolean;
    /**
     * Pauses the download.
     */
    pause(): void;
    /**
     * Resumes the download that has been paused. Note: To enable resumable downloads
     * the server you are downloading from must support range requests and provide both
     * Last-Modified and ETag header values. Otherwise resume() will dismiss previously
     * received bytes and restart the download from the beginning.
     */
    resume(): void;
    /**
     * This API allows the user to set custom options for the save dialog that opens
     * for the download item by default. The API is only available in session's
     * will-download callback function.
     */
    setSaveDialogOptions(options: SaveDialogOptions): void;
    /**
     * The API is only available in session's will-download callback function. If user
     * doesn't set the save path via the API, Electron will use the original routine to
     * determine the save path(Usually prompts a save dialog).
     */
    setSavePath(path: string): void;
  }

  interface Event extends GlobalEvent {

    // Docs: http://electronjs.org/docs/api/structures/event

    preventDefault: (() => void);
  }

  interface FileFilter {

    // Docs: http://electronjs.org/docs/api/structures/file-filter

    extensions: string[];
    name: string;
  }

  interface GlobalShortcut extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/global-shortcut

    /**
     * When the accelerator is already taken by other applications, this call will
     * still return false. This behavior is intended by operating systems, since they
     * don't want applications to fight for global shortcuts.
     */
    isRegistered(accelerator: Accelerator): boolean;
    /**
     * Registers a global shortcut of accelerator. The callback is called when the
     * registered shortcut is pressed by the user. When the accelerator is already
     * taken by other applications, this call will silently fail. This behavior is
     * intended by operating systems, since they don't want applications to fight for
     * global shortcuts. The following accelerators will not be registered successfully
     * on macOS 10.14 Mojave unless the app has been authorized as a trusted
     * accessibility client:
     */
    register(accelerator: Accelerator, callback: Function): boolean;
    /**
     * Registers a global shortcut of all accelerator items in accelerators. The
     * callback is called when any of the registered shortcuts are pressed by the user.
     * When a given accelerator is already taken by other applications, this call will
     * silently fail. This behavior is intended by operating systems, since they don't
     * want applications to fight for global shortcuts. The following accelerators will
     * not be registered successfully on macOS 10.14 Mojave unless the app has been
     * authorized as a trusted accessibility client:
     */
    registerAll(accelerators: string[], callback: Function): void;
    /**
     * Unregisters the global shortcut of accelerator.
     */
    unregister(accelerator: Accelerator): void;
    /**
     * Unregisters all of the global shortcuts.
     */
    unregisterAll(): void;
  }

  interface GPUFeatureStatus {

    // Docs: http://electronjs.org/docs/api/structures/gpu-feature-status

    /**
     * Canvas.
     */
    '2d_canvas': string;
    /**
     * Flash.
     */
    flash_3d: string;
    /**
     * Flash Stage3D.
     */
    flash_stage3d: string;
    /**
     * Flash Stage3D Baseline profile.
     */
    flash_stage3d_baseline: string;
    /**
     * Compositing.
     */
    gpu_compositing: string;
    /**
     * Multiple Raster Threads.
     */
    multiple_raster_threads: string;
    /**
     * Native GpuMemoryBuffers.
     */
    native_gpu_memory_buffers: string;
    /**
     * Rasterization.
     */
    rasterization: string;
    /**
     * Video Decode.
     */
    video_decode: string;
    /**
     * Video Encode.
     */
    video_encode: string;
    /**
     * VPx Video Decode.
     */
    vpx_decode: string;
    /**
     * WebGL.
     */
    webgl: string;
    /**
     * WebGL2.
     */
    webgl2: string;
  }

  interface InAppPurchase extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/in-app-purchase

    /**
     * Emitted when one or more transactions have been updated.
     */
    on(event: 'transactions-updated', listener: (event: Event,
                                                 /**
                                                  * Array of objects.
                                                  */
                                                 transactions: Transaction[]) => void): this;
    once(event: 'transactions-updated', listener: (event: Event,
                                                 /**
                                                  * Array of objects.
                                                  */
                                                 transactions: Transaction[]) => void): this;
    addListener(event: 'transactions-updated', listener: (event: Event,
                                                 /**
                                                  * Array of objects.
                                                  */
                                                 transactions: Transaction[]) => void): this;
    removeListener(event: 'transactions-updated', listener: (event: Event,
                                                 /**
                                                  * Array of objects.
                                                  */
                                                 transactions: Transaction[]) => void): this;
    canMakePayments(): boolean;
    /**
     * Completes all pending transactions.
     */
    finishAllTransactions(): void;
    /**
     * Completes the pending transactions corresponding to the date.
     */
    finishTransactionByDate(date: string): void;
    /**
     * Retrieves the product descriptions. Deprecated Soon
     */
    getProducts(productIDs: string[], callback: (products: Product[]) => void): void;
    /**
     * Retrieves the product descriptions.
     */
    getProducts(productIDs: string[]): Promise<Electron.Product[]>;
    getReceiptURL(): string;
    /**
     * You should listen for the transactions-updated event as soon as possible and
     * certainly before you call purchaseProduct. Deprecated Soon
     */
    purchaseProduct(productID: string, quantity?: number, callback?: (isProductValid: boolean) => void): void;
    /**
     * You should listen for the transactions-updated event as soon as possible and
     * certainly before you call purchaseProduct.
     */
    purchaseProduct(productID: string, quantity?: number): Promise<boolean>;
  }

  class IncomingMessage extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/incoming-message

    /**
     * Emitted when a request has been canceled during an ongoing HTTP transaction.
     */
    on(event: 'aborted', listener: Function): this;
    once(event: 'aborted', listener: Function): this;
    addListener(event: 'aborted', listener: Function): this;
    removeListener(event: 'aborted', listener: Function): this;
    /**
     * The data event is the usual method of transferring response data into
     * applicative code.
     */
    on(event: 'data', listener: (
                                 /**
                                  * A chunk of response body's data.
                                  */
                                 chunk: Buffer) => void): this;
    once(event: 'data', listener: (
                                 /**
                                  * A chunk of response body's data.
                                  */
                                 chunk: Buffer) => void): this;
    addListener(event: 'data', listener: (
                                 /**
                                  * A chunk of response body's data.
                                  */
                                 chunk: Buffer) => void): this;
    removeListener(event: 'data', listener: (
                                 /**
                                  * A chunk of response body's data.
                                  */
                                 chunk: Buffer) => void): this;
    /**
     * Indicates that response body has ended.
     */
    on(event: 'end', listener: Function): this;
    once(event: 'end', listener: Function): this;
    addListener(event: 'end', listener: Function): this;
    removeListener(event: 'end', listener: Function): this;
    /**
     * error Error - Typically holds an error string identifying failure root cause.
     * Emitted when an error was encountered while streaming response data events. For
     * instance, if the server closes the underlying while the response is still
     * streaming, an error event will be emitted on the response object and a close
     * event will subsequently follow on the request object.
     */
    on(event: 'error', listener: Function): this;
    once(event: 'error', listener: Function): this;
    addListener(event: 'error', listener: Function): this;
    removeListener(event: 'error', listener: Function): this;
    headers: any;
    httpVersion: string;
    httpVersionMajor: number;
    httpVersionMinor: number;
    statusCode: number;
    statusMessage: string;
  }

  interface IOCounters {

    // Docs: http://electronjs.org/docs/api/structures/io-counters

    /**
     * Then number of I/O other operations.
     */
    otherOperationCount: number;
    /**
     * Then number of I/O other transfers.
     */
    otherTransferCount: number;
    /**
     * The number of I/O read operations.
     */
    readOperationCount: number;
    /**
     * The number of I/O read transfers.
     */
    readTransferCount: number;
    /**
     * The number of I/O write operations.
     */
    writeOperationCount: number;
    /**
     * The number of I/O write transfers.
     */
    writeTransferCount: number;
  }

  interface IpcMain extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/ipc-main

    /**
     * Listens to channel, when a new message arrives listener would be called with
     * listener(event, args...).
     */
    on(channel: string, listener: (event: IpcMainEvent, ...args: any[]) => void): this;
    /**
     * Adds a one time listener function for the event. This listener is invoked only
     * the next time a message is sent to channel, after which it is removed.
     */
    once(channel: string, listener: (event: IpcMainEvent, ...args: any[]) => void): this;
    /**
     * Removes listeners of the specified channel.
     */
    removeAllListeners(channel: string): this;
    /**
     * Removes the specified listener from the listener array for the specified
     * channel.
     */
    removeListener(channel: string, listener: Function): this;
  }

  interface IpcMainEvent extends Event {

    // Docs: http://electronjs.org/docs/api/structures/ipc-main-event

    /**
     * The ID of the renderer frame that sent this message
     */
    frameId: number;
    /**
     * A function that will send an IPC message to the renderer frame that sent the
     * original message that you are currently handling. You should use this method to
     * "reply" to the sent message in order to guaruntee the reply will go to the
     * correct process and frame.
     */
    reply: Function;
    /**
     * Set this to the value to be returned in a syncronous message
     */
    returnValue: any;
    /**
     * Returns the webContents that sent the message
     */
    sender: WebContents;
  }

  interface IpcRenderer extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/ipc-renderer

    /**
     * Listens to channel, when a new message arrives listener would be called with
     * listener(event, args...).
     */
    on(channel: string, listener: (event: IpcRendererEvent, ...args: any[]) => void): this;
    /**
     * Adds a one time listener function for the event. This listener is invoked only
     * the next time a message is sent to channel, after which it is removed.
     */
    once(channel: string, listener: (event: IpcRendererEvent, ...args: any[]) => void): this;
    /**
     * Removes all listeners, or those of the specified channel.
     */
    removeAllListeners(channel: string): this;
    /**
     * Removes the specified listener from the listener array for the specified
     * channel.
     */
    removeListener(channel: string, listener: Function): this;
    /**
     * Send a message to the main process asynchronously via channel, you can also send
     * arbitrary arguments. Arguments will be serialized in JSON internally and hence
     * no functions or prototype chain will be included. The main process handles it by
     * listening for channel with ipcMain module.
     */
    send(channel: string, ...args: any[]): void;
    /**
     * Send a message to the main process synchronously via channel, you can also send
     * arbitrary arguments. Arguments will be serialized in JSON internally and hence
     * no functions or prototype chain will be included. The main process handles it by
     * listening for channel with ipcMain module, and replies by setting
     * event.returnValue. Note: Sending a synchronous message will block the whole
     * renderer process, unless you know what you are doing you should never use it.
     */
    sendSync(channel: string, ...args: any[]): any;
    /**
     * Sends a message to a window with webContentsId via channel.
     */
    sendTo(webContentsId: number, channel: string, ...args: any[]): void;
    /**
     * Like ipcRenderer.send but the event will be sent to the <webview> element in the
     * host page instead of the main process.
     */
    sendToHost(channel: string, ...args: any[]): void;
  }

  interface IpcRendererEvent extends Event {

    // Docs: http://electronjs.org/docs/api/structures/ipc-renderer-event

    /**
     * The IpcRenderer instance that emitted the event originally
     */
    sender: IpcRenderer;
    /**
     * The webContents.id that sent the message, you can call
     * event.sender.sendTo(event.senderId, ...) to reply to the message, see for more
     * information. This only applies to messages sent from a different renderer.
     * Messages sent directly from the main process set event.senderId to 0.
     */
    senderId: number;
  }

  interface JumpListCategory {

    // Docs: http://electronjs.org/docs/api/structures/jump-list-category

    /**
     * Array of objects if type is tasks or custom, otherwise it should be omitted.
     */
    items?: JumpListItem[];
    /**
     * Must be set if type is custom, otherwise it should be omitted.
     */
    name?: string;
    /**
     * One of the following:
     */
    type?: ('tasks' | 'frequent' | 'recent' | 'custom');
  }

  interface JumpListItem {

    // Docs: http://electronjs.org/docs/api/structures/jump-list-item

    /**
     * The command line arguments when program is executed. Should only be set if type
     * is task.
     */
    args?: string;
    /**
     * Description of the task (displayed in a tooltip). Should only be set if type is
     * task.
     */
    description?: string;
    /**
     * The index of the icon in the resource file. If a resource file contains multiple
     * icons this value can be used to specify the zero-based index of the icon that
     * should be displayed for this task. If a resource file contains only one icon,
     * this property should be set to zero.
     */
    iconIndex?: number;
    /**
     * The absolute path to an icon to be displayed in a Jump List, which can be an
     * arbitrary resource file that contains an icon (e.g. .ico, .exe, .dll). You can
     * usually specify process.execPath to show the program icon.
     */
    iconPath?: string;
    /**
     * Path of the file to open, should only be set if type is file.
     */
    path?: string;
    /**
     * Path of the program to execute, usually you should specify process.execPath
     * which opens the current program. Should only be set if type is task.
     */
    program?: string;
    /**
     * The text to be displayed for the item in the Jump List. Should only be set if
     * type is task.
     */
    title?: string;
    /**
     * One of the following:
     */
    type?: ('task' | 'separator' | 'file');
    /**
     * The working directory. Default is empty.
     */
    workingDirectory?: string;
  }

  interface KeyboardEvent extends Event {

    // Docs: http://electronjs.org/docs/api/structures/keyboard-event

    /**
     * whether an Alt key was used in an accelerator to trigger the Event
     */
    altKey?: boolean;
    /**
     * whether the Control key was used in an accelerator to trigger the Event
     */
    ctrlKey?: boolean;
    /**
     * whether a meta key was used in an accelerator to trigger the Event
     */
    metaKey?: boolean;
    /**
     * whether a Shift key was used in an accelerator to trigger the Event
     */
    shiftKey?: boolean;
    /**
     * whether an accelerator was used to trigger the event as opposed to another user
     * gesture like mouse click
     */
    triggeredByAccelerator?: boolean;
  }

  interface MemoryUsageDetails {

    // Docs: http://electronjs.org/docs/api/structures/memory-usage-details

    count: number;
    liveSize: number;
    size: number;
  }

  class Menu {

    // Docs: http://electronjs.org/docs/api/menu

    /**
     * Emitted when a popup is closed either manually or with menu.closePopup().
     */
    on(event: 'menu-will-close', listener: (event: Event) => void): this;
    once(event: 'menu-will-close', listener: (event: Event) => void): this;
    addListener(event: 'menu-will-close', listener: (event: Event) => void): this;
    removeListener(event: 'menu-will-close', listener: (event: Event) => void): this;
    /**
     * Emitted when menu.popup() is called.
     */
    on(event: 'menu-will-show', listener: (event: Event) => void): this;
    once(event: 'menu-will-show', listener: (event: Event) => void): this;
    addListener(event: 'menu-will-show', listener: (event: Event) => void): this;
    removeListener(event: 'menu-will-show', listener: (event: Event) => void): this;
    constructor();
    /**
     * Generally, the template is an array of options for constructing a MenuItem. The
     * usage can be referenced above. You can also attach other fields to the element
     * of the template and they will become properties of the constructed menu items.
     */
    static buildFromTemplate(template: Array<(MenuItemConstructorOptions) | (MenuItem)>): Menu;
    /**
     * Note: The returned Menu instance doesn't support dynamic addition or removal of
     * menu items. Instance properties can still be dynamically modified.
     */
    static getApplicationMenu(): (Menu) | (null);
    /**
     * Sends the action to the first responder of application. This is used for
     * emulating default macOS menu behaviors. Usually you would use the role property
     * of a MenuItem. See the macOS Cocoa Event Handling Guide for more information on
     * macOS' native actions.
     */
    static sendActionToFirstResponder(action: string): void;
    /**
     * Sets menu as the application menu on macOS. On Windows and Linux, the menu will
     * be set as each window's top menu. Also on Windows and Linux, you can use a & in
     * the top-level item name to indicate which letter should get a generated
     * accelerator. For example, using &File for the file menu would result in a
     * generated Alt-F accelerator that opens the associated menu. The indicated
     * character in the button label gets an underline. The & character is not
     * displayed on the button label. Passing null will suppress the default menu. On
     * Windows and Linux, this has the additional effect of removing the menu bar from
     * the window. Note: The default menu will be created automatically if the app does
     * not set one. It contains standard items such as File, Edit, View, Window and
     * Help.
     */
    static setApplicationMenu(menu: (Menu) | (null)): void;
    /**
     * Appends the menuItem to the menu.
     */
    append(menuItem: MenuItem): void;
    /**
     * Closes the context menu in the browserWindow.
     */
    closePopup(browserWindow?: BrowserWindow): void;
    getMenuItemById(id: string): MenuItem;
    /**
     * Inserts the menuItem to the pos position of the menu.
     */
    insert(pos: number, menuItem: MenuItem): void;
    /**
     * Pops up this menu as a context menu in the BrowserWindow.
     */
    popup(options?: PopupOptions): void;
    items: MenuItem[];
  }

  class MenuItem {

    // Docs: http://electronjs.org/docs/api/menu-item

    constructor(options: MenuItemConstructorOptions);
    accelerator: string;
    checked: boolean;
    click: Function;
    commandId: number;
    enabled: boolean;
    icon: NativeImage;
    id: string;
    label: string;
    menu: Menu;
    registerAccelerator: boolean;
    role: string;
    sublabel: string;
    submenu: Menu;
    type: string;
    visible: boolean;
  }

  interface MimeTypedBuffer {

    // Docs: http://electronjs.org/docs/api/structures/mime-typed-buffer

    /**
     * The actual Buffer content.
     */
    data: Buffer;
    /**
     * The mimeType of the Buffer that you are sending.
     */
    mimeType: string;
  }

  class NativeImage {

    // Docs: http://electronjs.org/docs/api/native-image

    /**
     * Creates an empty NativeImage instance.
     */
    static createEmpty(): NativeImage;
    /**
     * Creates a new NativeImage instance from buffer that contains the raw bitmap
     * pixel data returned by toBitmap(). The specific format is platform-dependent.
     */
    static createFromBitmap(buffer: Buffer, options: CreateFromBitmapOptions): NativeImage;
    /**
     * Creates a new NativeImage instance from buffer. Tries to decode as PNG or JPEG
     * first.
     */
    static createFromBuffer(buffer: Buffer, options?: CreateFromBufferOptions): NativeImage;
    /**
     * Creates a new NativeImage instance from dataURL.
     */
    static createFromDataURL(dataURL: string): NativeImage;
    /**
     * Creates a new NativeImage instance from the NSImage that maps to the given image
     * name. See NSImageName for a list of possible values. The hslShift is applied to
     * the image with the following rules This means that [-1, 0, 1] will make the
     * image completely white and [-1, 1, 0] will make the image completely black. In
     * some cases, the NSImageName doesn't match its string representation; one example
     * of this is NSFolderImageName, whose string representation would actually be
     * NSFolder. Therefore, you'll need to determine the correct string representation
     * for your image before passing it in. This can be done with the following: echo
     * -e '#import <Cocoa/Cocoa.h>\nint main() { NSLog(@"%@", SYSTEM_IMAGE_NAME); }' |
     * clang -otest -x objective-c -framework Cocoa - && ./test where SYSTEM_IMAGE_NAME
     * should be replaced with any value from this list.
     */
    static createFromNamedImage(imageName: string, hslShift: number[]): NativeImage;
    /**
     * Creates a new NativeImage instance from a file located at path. This method
     * returns an empty image if the path does not exist, cannot be read, or is not a
     * valid image.
     */
    static createFromPath(path: string): NativeImage;
    /**
     * Add an image representation for a specific scale factor. This can be used to
     * explicitly add different scale factor representations to an image. This can be
     * called on empty images.
     */
    addRepresentation(options: AddRepresentationOptions): void;
    crop(rect: Rectangle): NativeImage;
    getAspectRatio(): number;
    /**
     * The difference between getBitmap() and toBitmap() is, getBitmap() does not copy
     * the bitmap data, so you have to use the returned Buffer immediately in current
     * event loop tick, otherwise the data might be changed or destroyed.
     */
    getBitmap(options?: BitmapOptions): Buffer;
    /**
     * Notice that the returned pointer is a weak pointer to the underlying native
     * image instead of a copy, so you must ensure that the associated nativeImage
     * instance is kept around.
     */
    getNativeHandle(): Buffer;
    getSize(): Size;
    isEmpty(): boolean;
    isTemplateImage(): boolean;
    /**
     * If only the height or the width are specified then the current aspect ratio will
     * be preserved in the resized image.
     */
    resize(options: ResizeOptions): NativeImage;
    /**
     * Marks the image as a template image.
     */
    setTemplateImage(option: boolean): void;
    toBitmap(options?: ToBitmapOptions): Buffer;
    toDataURL(options?: ToDataURLOptions): string;
    toJPEG(quality: number): Buffer;
    toPNG(options?: ToPNGOptions): Buffer;
  }

  interface Net extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/net

    /**
     * Creates a ClientRequest instance using the provided options which are directly
     * forwarded to the ClientRequest constructor. The net.request method would be used
     * to issue both secure and insecure HTTP requests according to the specified
     * protocol scheme in the options object.
     */
    request(options: (any) | (string)): ClientRequest;
  }

  interface NetLog extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/net-log

    /**
     * Starts recording network events to path.
     */
    startLogging(path: string): void;
    /**
     * Stops recording network events. If not called, net logging will automatically
     * end when app quits. Deprecated Soon
     */
    stopLogging(callback?: (path: string) => void): void;
    /**
     * Stops recording network events. If not called, net logging will automatically
     * end when app quits.
     */
    stopLogging(): Promise<string>;
    /**
     * A Boolean property that indicates whether network logs are recorded.
     */
    currentlyLogging?: boolean;
    /**
     * A String property that returns the path to the current log file.
     */
    currentlyLoggingPath?: string;
  }

  class Notification extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/notification

    on(event: 'action', listener: (event: Event,
                                   /**
                                    * The index of the action that was activated.
                                    */
                                   index: number) => void): this;
    once(event: 'action', listener: (event: Event,
                                   /**
                                    * The index of the action that was activated.
                                    */
                                   index: number) => void): this;
    addListener(event: 'action', listener: (event: Event,
                                   /**
                                    * The index of the action that was activated.
                                    */
                                   index: number) => void): this;
    removeListener(event: 'action', listener: (event: Event,
                                   /**
                                    * The index of the action that was activated.
                                    */
                                   index: number) => void): this;
    /**
     * Emitted when the notification is clicked by the user.
     */
    on(event: 'click', listener: (event: Event) => void): this;
    once(event: 'click', listener: (event: Event) => void): this;
    addListener(event: 'click', listener: (event: Event) => void): this;
    removeListener(event: 'click', listener: (event: Event) => void): this;
    /**
     * Emitted when the notification is closed by manual intervention from the user.
     * This event is not guaranteed to be emitted in all cases where the notification
     * is closed.
     */
    on(event: 'close', listener: (event: Event) => void): this;
    once(event: 'close', listener: (event: Event) => void): this;
    addListener(event: 'close', listener: (event: Event) => void): this;
    removeListener(event: 'close', listener: (event: Event) => void): this;
    /**
     * Emitted when the user clicks the "Reply" button on a notification with hasReply:
     * true.
     */
    on(event: 'reply', listener: (event: Event,
                                  /**
                                   * The string the user entered into the inline reply field.
                                   */
                                  reply: string) => void): this;
    once(event: 'reply', listener: (event: Event,
                                  /**
                                   * The string the user entered into the inline reply field.
                                   */
                                  reply: string) => void): this;
    addListener(event: 'reply', listener: (event: Event,
                                  /**
                                   * The string the user entered into the inline reply field.
                                   */
                                  reply: string) => void): this;
    removeListener(event: 'reply', listener: (event: Event,
                                  /**
                                   * The string the user entered into the inline reply field.
                                   */
                                  reply: string) => void): this;
    /**
     * Emitted when the notification is shown to the user, note this could be fired
     * multiple times as a notification can be shown multiple times through the show()
     * method.
     */
    on(event: 'show', listener: (event: Event) => void): this;
    once(event: 'show', listener: (event: Event) => void): this;
    addListener(event: 'show', listener: (event: Event) => void): this;
    removeListener(event: 'show', listener: (event: Event) => void): this;
    constructor(options: NotificationConstructorOptions);
    static isSupported(): boolean;
    /**
     * Dismisses the notification.
     */
    close(): void;
    /**
     * Immediately shows the notification to the user, please note this means unlike
     * the HTML5 Notification implementation, instantiating a new Notification does not
     * immediately show it to the user, you need to call this method before the OS will
     * display it. If the notification has been shown before, this method will dismiss
     * the previously shown notification and create a new one with identical
     * properties.
     */
    show(): void;
  }

  interface NotificationAction {

    // Docs: http://electronjs.org/docs/api/structures/notification-action

    /**
     * The label for the given action.
     */
    text?: string;
    /**
     * The type of action, can be button.
     */
    type: ('button');
  }

  interface Point {

    // Docs: http://electronjs.org/docs/api/structures/point

    x: number;
    y: number;
  }

  interface PowerMonitor extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/power-monitor

    /**
     * Emitted when the system is about to lock the screen.
     */
    on(event: 'lock-screen', listener: Function): this;
    once(event: 'lock-screen', listener: Function): this;
    addListener(event: 'lock-screen', listener: Function): this;
    removeListener(event: 'lock-screen', listener: Function): this;
    /**
     * Emitted when the system changes to AC power.
     */
    on(event: 'on-ac', listener: Function): this;
    once(event: 'on-ac', listener: Function): this;
    addListener(event: 'on-ac', listener: Function): this;
    removeListener(event: 'on-ac', listener: Function): this;
    /**
     * Emitted when system changes to battery power.
     */
    on(event: 'on-battery', listener: Function): this;
    once(event: 'on-battery', listener: Function): this;
    addListener(event: 'on-battery', listener: Function): this;
    removeListener(event: 'on-battery', listener: Function): this;
    /**
     * Emitted when system is resuming.
     */
    on(event: 'resume', listener: Function): this;
    once(event: 'resume', listener: Function): this;
    addListener(event: 'resume', listener: Function): this;
    removeListener(event: 'resume', listener: Function): this;
    /**
     * Emitted when the system is about to reboot or shut down. If the event handler
     * invokes e.preventDefault(), Electron will attempt to delay system shutdown in
     * order for the app to exit cleanly. If e.preventDefault() is called, the app
     * should exit as soon as possible by calling something like app.quit().
     */
    on(event: 'shutdown', listener: Function): this;
    once(event: 'shutdown', listener: Function): this;
    addListener(event: 'shutdown', listener: Function): this;
    removeListener(event: 'shutdown', listener: Function): this;
    /**
     * Emitted when the system is suspending.
     */
    on(event: 'suspend', listener: Function): this;
    once(event: 'suspend', listener: Function): this;
    addListener(event: 'suspend', listener: Function): this;
    removeListener(event: 'suspend', listener: Function): this;
    /**
     * Emitted as soon as the systems screen is unlocked.
     */
    on(event: 'unlock-screen', listener: Function): this;
    once(event: 'unlock-screen', listener: Function): this;
    addListener(event: 'unlock-screen', listener: Function): this;
    removeListener(event: 'unlock-screen', listener: Function): this;
    /**
     * Calculate the system idle state. idleThreshold is the amount of time (in
     * seconds) before considered idle.  locked is available on supported systems only.
     */
    getSystemIdleState(idleThreshold: number): ('active' | 'idle' | 'locked' | 'unknown');
    /**
     * Calculate system idle time in seconds.
     */
    getSystemIdleTime(): number;
    /**
     * Calculate the system idle state. idleThreshold is the amount of time (in
     * seconds) before considered idle. callback will be called synchronously on some
     * systems and with an idleState argument that describes the system's state. locked
     * is available on supported systems only.
     */
    querySystemIdleState(idleThreshold: number, callback: (idleState: 'active' | 'idle' | 'locked' | 'unknown') => void): void;
    /**
     * Calculate system idle time in seconds.
     */
    querySystemIdleTime(callback: (idleTime: number) => void): void;
  }

  interface PowerSaveBlocker extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/power-save-blocker

    isStarted(id: number): boolean;
    /**
     * Starts preventing the system from entering lower-power mode. Returns an integer
     * identifying the power save blocker. Note: prevent-display-sleep has higher
     * precedence over prevent-app-suspension. Only the highest precedence type takes
     * effect. In other words, prevent-display-sleep always takes precedence over
     * prevent-app-suspension. For example, an API calling A requests for
     * prevent-app-suspension, and another calling B requests for
     * prevent-display-sleep. prevent-display-sleep will be used until B stops its
     * request. After that, prevent-app-suspension is used.
     */
    start(type: 'prevent-app-suspension' | 'prevent-display-sleep'): number;
    /**
     * Stops the specified power save blocker.
     */
    stop(id: number): void;
  }

  interface PrinterInfo {

    // Docs: http://electronjs.org/docs/api/structures/printer-info

    description: string;
    isDefault: boolean;
    name: string;
    status: number;
  }

  interface ProcessMemoryInfo {

    // Docs: http://electronjs.org/docs/api/structures/process-memory-info

    /**
     * The amount of memory not shared by other processes, such as JS heap or HTML
     * content in Kilobytes.
     */
    private: number;
    /**
     * and The amount of memory currently pinned to actual physical RAM in Kilobytes.
     */
    residentSet: number;
    /**
     * The amount of memory shared between processes, typically memory consumed by the
     * Electron code itself in Kilobytes.
     */
    shared: number;
  }

  interface ProcessMetric {

    // Docs: http://electronjs.org/docs/api/structures/process-metric

    /**
     * CPU usage of the process.
     */
    cpu: CPUUsage;
    /**
     * Process id of the process.
     */
    pid: number;
    /**
     * Process type. One of the following values:
     */
    type: ('Browser' | 'Tab' | 'Utility' | 'Zygote' | 'GPU' | 'Unknown');
  }

  interface Product {

    // Docs: http://electronjs.org/docs/api/structures/product

    /**
     * The total size of the content, in bytes.
     */
    contentLengths: number[];
    /**
     * A string that identifies the version of the content.
     */
    contentVersion: string;
    /**
     * The locale formatted price of the product.
     */
    formattedPrice: string;
    /**
     * A Boolean value that indicates whether the App Store has downloadable content
     * for this product. true if at least one file has been associated with the
     * product.
     */
    isDownloadable: boolean;
    /**
     * A description of the product.
     */
    localizedDescription: string;
    /**
     * The name of the product.
     */
    localizedTitle: string;
    /**
     * The cost of the product in the local currency.
     */
    price: number;
    /**
     * The string that identifies the product to the Apple App Store.
     */
    productIdentifier: string;
  }

  interface Protocol extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/protocol

    /**
     * Intercepts scheme protocol and uses handler as the protocol's new handler which
     * sends a Buffer as a response.
     */
    interceptBufferProtocol(scheme: string, handler: (request: InterceptBufferProtocolRequest, callback: (buffer?: Buffer) => void) => void, completion?: (error: Error) => void): void;
    /**
     * Intercepts scheme protocol and uses handler as the protocol's new handler which
     * sends a file as a response.
     */
    interceptFileProtocol(scheme: string, handler: (request: InterceptFileProtocolRequest, callback: (filePath: string) => void) => void, completion?: (error: Error) => void): void;
    /**
     * Intercepts scheme protocol and uses handler as the protocol's new handler which
     * sends a new HTTP request as a response.
     */
    interceptHttpProtocol(scheme: string, handler: (request: InterceptHttpProtocolRequest, callback: (redirectRequest: RedirectRequest) => void) => void, completion?: (error: Error) => void): void;
    /**
     * Same as protocol.registerStreamProtocol, except that it replaces an existing
     * protocol handler.
     */
    interceptStreamProtocol(scheme: string, handler: (request: InterceptStreamProtocolRequest, callback: (stream?: (NodeJS.ReadableStream) | (StreamProtocolResponse)) => void) => void, completion?: (error: Error) => void): void;
    /**
     * Intercepts scheme protocol and uses handler as the protocol's new handler which
     * sends a String as a response.
     */
    interceptStringProtocol(scheme: string, handler: (request: InterceptStringProtocolRequest, callback: (data?: string) => void) => void, completion?: (error: Error) => void): void;
    /**
     * The callback will be called with a boolean that indicates whether there is
     * already a handler for scheme. Deprecated Soon
     */
    isProtocolHandled(scheme: string, callback: (handled: boolean) => void): void;
    isProtocolHandled(scheme: string): Promise<boolean>;
    /**
     * Registers a protocol of scheme that will send a Buffer as a response. The usage
     * is the same with registerFileProtocol, except that the callback should be called
     * with either a Buffer object or an object that has the data, mimeType, and
     * charset properties. Example:
     */
    registerBufferProtocol(scheme: string, handler: (request: RegisterBufferProtocolRequest, callback: (buffer?: (Buffer) | (MimeTypedBuffer)) => void) => void, completion?: (error: Error) => void): void;
    /**
     * Registers a protocol of scheme that will send the file as a response. The
     * handler will be called with handler(request, callback) when a request is going
     * to be created with scheme. completion will be called with completion(null) when
     * scheme is successfully registered or completion(error) when failed. To handle
     * the request, the callback should be called with either the file's path or an
     * object that has a path property, e.g. callback(filePath) or callback({ path:
     * filePath }). The object may also have a headers property which gives a map of
     * headers to values for the response headers, e.g. callback({ path: filePath,
     * headers: {"Content-Security-Policy": "default-src 'none'"]}). When callback is
     * called with nothing, a number, or an object that has an error property, the
     * request will fail with the error number you specified. For the available error
     * numbers you can use, please see the net error list. By default the scheme is
     * treated like http:, which is parsed differently than protocols that follow the
     * "generic URI syntax" like file:.
     */
    registerFileProtocol(scheme: string, handler: (request: RegisterFileProtocolRequest, callback: (filePath?: string) => void) => void, completion?: (error: Error) => void): void;
    /**
     * Registers a protocol of scheme that will send an HTTP request as a response. The
     * usage is the same with registerFileProtocol, except that the callback should be
     * called with a redirectRequest object that has the url, method, referrer,
     * uploadData and session properties. By default the HTTP request will reuse the
     * current session. If you want the request to have a different session you should
     * set session to null. For POST requests the uploadData object must be provided.
     */
    registerHttpProtocol(scheme: string, handler: (request: RegisterHttpProtocolRequest, callback: (redirectRequest: RedirectRequest) => void) => void, completion?: (error: Error) => void): void;
    /**
     * Note: This method can only be used before the ready event of the app module gets
     * emitted and can be called only once. Registers the scheme as standard, secure,
     * bypasses content security policy for resources, allows registering ServiceWorker
     * and supports fetch API. Specify a privilege with the value of true to enable the
     * capability. An example of registering a privileged scheme, with bypassing
     * Content Security Policy: A standard scheme adheres to what RFC 3986 calls
     * generic URI syntax. For example http and https are standard schemes, while file
     * is not. Registering a scheme as standard, will allow relative and absolute
     * resources to be resolved correctly when served. Otherwise the scheme will behave
     * like the file protocol, but without the ability to resolve relative URLs. For
     * example when you load following page with custom protocol without registering it
     * as standard scheme, the image will not be loaded because non-standard schemes
     * can not recognize relative URLs: Registering a scheme as standard will allow
     * access to files through the FileSystem API. Otherwise the renderer will throw a
     * security error for the scheme. By default web storage apis (localStorage,
     * sessionStorage, webSQL, indexedDB, cookies) are disabled for non standard
     * schemes. So in general if you want to register a custom protocol to replace the
     * http protocol, you have to register it as a standard scheme.
     * protocol.registerSchemesAsPrivileged can be used to replicate the functionality
     * of the previous protocol.registerStandardSchemes, webFrame.registerURLSchemeAs*
     * and protocol.registerServiceWorkerSchemes functions that existed prior to
     * Electron 5.0.0, for example: before (<= v4.x) after (>= v5.x)
     */
    registerSchemesAsPrivileged(customSchemes: CustomScheme[]): void;
    /**
     * Registers a protocol of scheme that will send a Readable as a response. The
     * usage is similar to the other register{Any}Protocol, except that the callback
     * should be called with either a Readable object or an object that has the data,
     * statusCode, and headers properties. Example: It is possible to pass any object
     * that implements the readable stream API (emits data/end/error events). For
     * example, here's how a file could be returned:
     */
    registerStreamProtocol(scheme: string, handler: (request: RegisterStreamProtocolRequest, callback: (stream?: (NodeJS.ReadableStream) | (StreamProtocolResponse)) => void) => void, completion?: (error: Error) => void): void;
    /**
     * Registers a protocol of scheme that will send a String as a response. The usage
     * is the same with registerFileProtocol, except that the callback should be called
     * with either a String or an object that has the data, mimeType, and charset
     * properties.
     */
    registerStringProtocol(scheme: string, handler: (request: RegisterStringProtocolRequest, callback: (data?: string) => void) => void, completion?: (error: Error) => void): void;
    /**
     * Remove the interceptor installed for scheme and restore its original handler.
     */
    uninterceptProtocol(scheme: string, completion?: (error: Error) => void): void;
    /**
     * Unregisters the custom protocol of scheme.
     */
    unregisterProtocol(scheme: string, completion?: (error: Error) => void): void;
  }

  interface Rectangle {

    // Docs: http://electronjs.org/docs/api/structures/rectangle

    /**
     * The height of the rectangle (must be an integer).
     */
    height: number;
    /**
     * The width of the rectangle (must be an integer).
     */
    width: number;
    /**
     * The x coordinate of the origin of the rectangle (must be an integer).
     */
    x: number;
    /**
     * The y coordinate of the origin of the rectangle (must be an integer).
     */
    y: number;
  }

  interface Referrer {

    // Docs: http://electronjs.org/docs/api/structures/referrer

    /**
     * Can be default, unsafe-url, no-referrer-when-downgrade, no-referrer, origin,
     * strict-origin-when-cross-origin, same-origin or strict-origin. See the for more
     * details on the meaning of these values.
     */
    policy: ('default' | 'unsafe-url' | 'no-referrer-when-downgrade' | 'no-referrer' | 'origin' | 'strict-origin-when-cross-origin' | 'same-origin' | 'strict-origin');
    /**
     * HTTP Referrer URL.
     */
    url: string;
  }

  interface Remote extends MainInterface {

    // Docs: http://electronjs.org/docs/api/remote

    getCurrentWebContents(): WebContents;
    /**
     * Note: Do not use removeAllListeners on BrowserWindow. Use of this can remove all
     * blur listeners, disable click events on touch bar buttons, and other unintended
     * consequences.
     */
    getCurrentWindow(): BrowserWindow;
    getGlobal(name: string): any;
    /**
     * e.g.
     */
    require(module: string): any;
    /**
     * The process object in the main process. This is the same as
     * remote.getGlobal('process') but is cached.
     */
    process?: any;
  }

  interface RemoveClientCertificate {

    // Docs: http://electronjs.org/docs/api/structures/remove-client-certificate

    /**
     * Origin of the server whose associated client certificate must be removed from
     * the cache.
     */
    origin: string;
    /**
     * clientCertificate.
     */
    type: string;
  }

  interface RemovePassword {

    // Docs: http://electronjs.org/docs/api/structures/remove-password

    /**
     * When provided, the authentication info related to the origin will only be
     * removed otherwise the entire cache will be cleared.
     */
    origin?: string;
    /**
     * Credentials of the authentication. Must be provided if removing by origin.
     */
    password?: string;
    /**
     * Realm of the authentication. Must be provided if removing by origin.
     */
    realm?: string;
    /**
     * Scheme of the authentication. Can be basic, digest, ntlm, negotiate. Must be
     * provided if removing by origin.
     */
    scheme?: ('basic' | 'digest' | 'ntlm' | 'negotiate');
    /**
     * password.
     */
    type: string;
    /**
     * Credentials of the authentication. Must be provided if removing by origin.
     */
    username?: string;
  }

  interface Screen extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/screen

    /**
     * Emitted when newDisplay has been added.
     */
    on(event: 'display-added', listener: (event: Event,
                                          newDisplay: Display) => void): this;
    once(event: 'display-added', listener: (event: Event,
                                          newDisplay: Display) => void): this;
    addListener(event: 'display-added', listener: (event: Event,
                                          newDisplay: Display) => void): this;
    removeListener(event: 'display-added', listener: (event: Event,
                                          newDisplay: Display) => void): this;
    /**
     * Emitted when one or more metrics change in a display. The changedMetrics is an
     * array of strings that describe the changes. Possible changes are bounds,
     * workArea, scaleFactor and rotation.
     */
    on(event: 'display-metrics-changed', listener: (event: Event,
                                                    display: Display,
                                                    changedMetrics: string[]) => void): this;
    once(event: 'display-metrics-changed', listener: (event: Event,
                                                    display: Display,
                                                    changedMetrics: string[]) => void): this;
    addListener(event: 'display-metrics-changed', listener: (event: Event,
                                                    display: Display,
                                                    changedMetrics: string[]) => void): this;
    removeListener(event: 'display-metrics-changed', listener: (event: Event,
                                                    display: Display,
                                                    changedMetrics: string[]) => void): this;
    /**
     * Emitted when oldDisplay has been removed.
     */
    on(event: 'display-removed', listener: (event: Event,
                                            oldDisplay: Display) => void): this;
    once(event: 'display-removed', listener: (event: Event,
                                            oldDisplay: Display) => void): this;
    addListener(event: 'display-removed', listener: (event: Event,
                                            oldDisplay: Display) => void): this;
    removeListener(event: 'display-removed', listener: (event: Event,
                                            oldDisplay: Display) => void): this;
    /**
     * Converts a screen DIP point to a screen physical point. The DPI scale is
     * performed relative to the display containing the DIP point.
     */
    dipToScreenPoint(point: Point): Point;
    /**
     * Converts a screen DIP rect to a screen physical rect. The DPI scale is performed
     * relative to the display nearest to window. If window is null, scaling will be
     * performed to the display nearest to rect.
     */
    dipToScreenRect(window: (BrowserWindow) | (null), rect: Rectangle): Rectangle;
    getAllDisplays(): Display[];
    /**
     * The current absolute position of the mouse pointer.
     */
    getCursorScreenPoint(): Point;
    getDisplayMatching(rect: Rectangle): Display;
    getDisplayNearestPoint(point: Point): Display;
    getPrimaryDisplay(): Display;
    /**
     * Converts a screen physical point to a screen DIP point. The DPI scale is
     * performed relative to the display containing the physical point.
     */
    screenToDipPoint(point: Point): Point;
    /**
     * Converts a screen physical rect to a screen DIP rect. The DPI scale is performed
     * relative to the display nearest to window. If window is null, scaling will be
     * performed to the display nearest to rect.
     */
    screenToDipRect(window: (BrowserWindow) | (null), rect: Rectangle): Rectangle;
  }

  interface ScrubberItem {

    // Docs: http://electronjs.org/docs/api/structures/scrubber-item

    /**
     * The image to appear in this item.
     */
    icon?: NativeImage;
    /**
     * The text to appear in this item.
     */
    label?: string;
  }

  interface SegmentedControlSegment {

    // Docs: http://electronjs.org/docs/api/structures/segmented-control-segment

    /**
     * Whether this segment is selectable. Default: true.
     */
    enabled?: boolean;
    /**
     * The image to appear in this segment.
     */
    icon?: NativeImage;
    /**
     * The text to appear in this segment.
     */
    label?: string;
  }

  class Session extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/session

    /**
     * If partition starts with persist:, the page will use a persistent session
     * available to all pages in the app with the same partition. if there is no
     * persist: prefix, the page will use an in-memory session. If the partition is
     * empty then default session of the app will be returned. To create a Session with
     * options, you have to ensure the Session with the partition has never been used
     * before. There is no way to change the options of an existing Session object.
     */
    static fromPartition(partition: string, options?: FromPartitionOptions): Session;
    /**
     * A Session object, the default session object of the app.
     */
    static defaultSession?: Session;
    /**
     * Emitted when Electron is about to download item in webContents. Calling
     * event.preventDefault() will cancel the download and item will not be available
     * from next tick of the process.
     */
    on(event: 'will-download', listener: (event: Event,
                                          item: DownloadItem,
                                          webContents: WebContents) => void): this;
    once(event: 'will-download', listener: (event: Event,
                                          item: DownloadItem,
                                          webContents: WebContents) => void): this;
    addListener(event: 'will-download', listener: (event: Event,
                                          item: DownloadItem,
                                          webContents: WebContents) => void): this;
    removeListener(event: 'will-download', listener: (event: Event,
                                          item: DownloadItem,
                                          webContents: WebContents) => void): this;
    /**
     * Dynamically sets whether to always send credentials for HTTP NTLM or Negotiate
     * authentication.
     */
    allowNTLMCredentialsForDomains(domains: string): void;
    clearAuthCache(): Promise<void>;
    clearAuthCache(options: (RemovePassword) | (RemoveClientCertificate)): Promise<void>;
    /**
     * Clears the session’s HTTP authentication cache. Deprecated Soon
     */
    clearAuthCache(options: (RemovePassword) | (RemoveClientCertificate), callback: Function): void;
    /**
     * Clears the session’s HTTP cache.
     */
    clearCache(): Promise<void>;
    /**
     * Clears the session’s HTTP cache. Deprecated Soon
     */
    clearCache(callback: (error: number) => void): void;
    /**
     * Clears the host resolver cache.
     */
    clearHostResolverCache(): Promise<void>;
    /**
     * Clears the host resolver cache. Deprecated Soon
     */
    clearHostResolverCache(callback?: Function): void;
    /**
     * Clears the storage data for the current session. Deprecated Soon
     */
    clearStorageData(options?: ClearStorageDataOptions, callback?: Function): void;
    clearStorageData(options?: ClearStorageDataOptions): Promise<void>;
    /**
     * Allows resuming cancelled or interrupted downloads from previous Session. The
     * API will generate a DownloadItem that can be accessed with the will-download
     * event. The DownloadItem will not have any WebContents associated with it and the
     * initial state will be interrupted. The download will start only when the resume
     * API is called on the DownloadItem.
     */
    createInterruptedDownload(options: CreateInterruptedDownloadOptions): void;
    /**
     * Disables any network emulation already active for the session. Resets to the
     * original network configuration.
     */
    disableNetworkEmulation(): void;
    /**
     * Emulates network with the given configuration for the session.
     */
    enableNetworkEmulation(options: EnableNetworkEmulationOptions): void;
    /**
     * Writes any unwritten DOMStorage data to disk.
     */
    flushStorageData(): void;
    /**
     * Deprecated Soon
     */
    getBlobData(identifier: string, callback: (result: Buffer) => void): void;
    getBlobData(identifier: string): Promise<Buffer>;
    getCacheSize(): Promise<number>;
    /**
     * Callback is invoked with the session's current cache size. Deprecated Soon
     */
    getCacheSize(callback: (size: number, error: number) => void): void;
    getPreloads(): string[];
    getUserAgent(): string;
    resolveProxy(url: string): Promise<string>;
    /**
     * Resolves the proxy information for url. The callback will be called with
     * callback(proxy) when the request is performed. Deprecated Soon
     */
    resolveProxy(url: string, callback: (proxy: string) => void): void;
    /**
     * Sets the certificate verify proc for session, the proc will be called with
     * proc(request, callback) whenever a server certificate verification is requested.
     * Calling callback(0) accepts the certificate, calling callback(-2) rejects it.
     * Calling setCertificateVerifyProc(null) will revert back to default certificate
     * verify proc.
     */
    setCertificateVerifyProc(proc: (request: CertificateVerifyProcRequest, callback: (verificationResult: number) => void) => void): void;
    /**
     * Sets download saving directory. By default, the download directory will be the
     * Downloads under the respective app folder.
     */
    setDownloadPath(path: string): void;
    /**
     * Sets the handler which can be used to respond to permission checks for the
     * session. Returning true will allow the permission and false will reject it. To
     * clear the handler, call setPermissionCheckHandler(null).
     */
    setPermissionCheckHandler(handler: ((webContents: WebContents, permission: string, requestingOrigin: string, details: PermissionCheckHandlerDetails) => boolean) | (null)): void;
    /**
     * Sets the handler which can be used to respond to permission requests for the
     * session. Calling callback(true) will allow the permission and callback(false)
     * will reject it. To clear the handler, call setPermissionRequestHandler(null).
     */
    setPermissionRequestHandler(handler: ((webContents: WebContents, permission: string, callback: (permissionGranted: boolean) => void, details: PermissionRequestHandlerDetails) => void) | (null)): void;
    /**
     * Adds scripts that will be executed on ALL web contents that are associated with
     * this session just before normal preload scripts run.
     */
    setPreloads(preloads: string[]): void;
    /**
     * Sets the proxy settings. When pacScript and proxyRules are provided together,
     * the proxyRules option is ignored and pacScript configuration is applied. The
     * proxyRules has to follow the rules below: For example: The proxyBypassRules is a
     * comma separated list of rules described below:
     */
    setProxy(config: Config): Promise<void>;
    /**
     * Sets the proxy settings. When pacScript and proxyRules are provided together,
     * the proxyRules option is ignored and pacScript configuration is applied. The
     * proxyRules has to follow the rules below: For example: The proxyBypassRules is a
     * comma separated list of rules described below: Deprecated Soon
     */
    setProxy(config: Config, callback: Function): void;
    /**
     * Overrides the userAgent and acceptLanguages for this session. The
     * acceptLanguages must a comma separated ordered list of language codes, for
     * example "en-US,fr,de,ko,zh-CN,ja". This doesn't affect existing WebContents, and
     * each WebContents can use webContents.setUserAgent to override the session-wide
     * user agent.
     */
    setUserAgent(userAgent: string, acceptLanguages?: string): void;
    cookies: Cookies;
    netLog: NetLog;
    protocol: Protocol;
    webRequest: WebRequest;
  }

  interface Shell {

    // Docs: http://electronjs.org/docs/api/shell

    /**
     * Play the beep sound.
     */
    beep(): void;
    /**
     * Move the given file to trash and returns a boolean status for the operation.
     */
    moveItemToTrash(fullPath: string): boolean;
    /**
     * Open the given external protocol URL in the desktop's default manner. (For
     * example, mailto: URLs in the user's default mail agent).
     */
    openExternal(url: string, options?: OpenExternalOptions): Promise<void>;
    /**
     * Open the given external protocol URL in the desktop's default manner. (For
     * example, mailto: URLs in the user's default mail agent). Deprecated
     */
    openExternalSync(url: string, options?: OpenExternalSyncOptions): boolean;
    /**
     * Open the given file in the desktop's default manner.
     */
    openItem(fullPath: string): boolean;
    /**
     * Resolves the shortcut link at shortcutPath. An exception will be thrown when any
     * error happens.
     */
    readShortcutLink(shortcutPath: string): ShortcutDetails;
    /**
     * Show the given file in a file manager. If possible, select the file.
     */
    showItemInFolder(fullPath: string): void;
    /**
     * Creates or updates a shortcut link at shortcutPath.
     */
    writeShortcutLink(shortcutPath: string, operation: 'create' | 'update' | 'replace', options: ShortcutDetails): boolean;
    /**
     * Creates or updates a shortcut link at shortcutPath.
     */
    writeShortcutLink(shortcutPath: string, options: ShortcutDetails): boolean;
  }

  interface ShortcutDetails {

    // Docs: http://electronjs.org/docs/api/structures/shortcut-details

    /**
     * The Application User Model ID. Default is empty.
     */
    appUserModelId?: string;
    /**
     * The arguments to be applied to target when launching from this shortcut. Default
     * is empty.
     */
    args?: string;
    /**
     * The working directory. Default is empty.
     */
    cwd?: string;
    /**
     * The description of the shortcut. Default is empty.
     */
    description?: string;
    /**
     * The path to the icon, can be a DLL or EXE. icon and iconIndex have to be set
     * together. Default is empty, which uses the target's icon.
     */
    icon?: string;
    /**
     * The resource ID of icon when icon is a DLL or EXE. Default is 0.
     */
    iconIndex?: number;
    /**
     * The target to launch from this shortcut.
     */
    target: string;
  }

  interface Size {

    // Docs: http://electronjs.org/docs/api/structures/size

    height: number;
    width: number;
  }

  interface StreamProtocolResponse {

    // Docs: http://electronjs.org/docs/api/structures/stream-protocol-response

    /**
     * A Node.js readable stream representing the response body.
     */
    data: NodeJS.ReadableStream;
    /**
     * An object containing the response headers.
     */
    headers: Headers;
    /**
     * The HTTP response code.
     */
    statusCode: number;
  }

  interface SystemPreferences extends EventEmitter {

    // Docs: http://electronjs.org/docs/api/system-preferences

    on(event: 'accent-color-changed', listener: (event: Event,
                                                 /**
                                                  * The new RGBA color the user assigned to be their system accent color.
                                                  */
                                                 newColor: string) => void): this;
    once(event: 'accent-color-changed', listener: (event: Event,
                                                 /**
                                                  * The new RGBA color the user assigned to be their system accent color.
                                                  */
                                                 newColor: string) => void): this;
    addListener(event: 'accent-color-changed', listener: (event: Event,
                                                 /**
                                                  * The new RGBA color the user assigned to be their system accent color.
                                                  */
                                                 newColor: string) => void): this;
    removeListener(event: 'accent-color-changed', listener: (event: Event,
                                                 /**
                                                  * The new RGBA color the user assigned to be their system accent color.
                                                  */
                                                 newColor: string) => void): this;
    on(event: 'color-changed', listener: (event: Event) => void): this;
    once(event: 'color-changed', listener: (event: Event) => void): this;
    addListener(event: 'color-changed', listener: (event: Event) => void): this;
    removeListener(event: 'color-changed', listener: (event: Event) => void): this;
    on(event: 'high-contrast-color-scheme-changed', listener: (event: Event,
                                                               /**
                                                                * `true` if a high contrast theme is being used, `false` otherwise.
                                                                */
                                                               highContrastColorScheme: boolean) => void): this;
    once(event: 'high-contrast-color-scheme-changed', listener: (event: Event,
                                                               /**
                                                                * `true` if a high contrast theme is being used, `false` otherwise.
                                                                */
                                                               highContrastColorScheme: boolean) => void): this;
    addListener(event: 'high-contrast-color-scheme-changed', listener: (event: Event,
                                                               /**
                                                                * `true` if a high contrast theme is being used, `false` otherwise.
                                                                */
                                                               highContrastColorScheme: boolean) => void): this;
    removeListener(event: 'high-contrast-color-scheme-changed', listener: (event: Event,
                                                               /**
                                                                * `true` if a high contrast theme is being used, `false` otherwise.
                                                                */
                                                               highContrastColorScheme: boolean) => void): this;
    on(event: 'inverted-color-scheme-changed', listener: (event: Event,
                                                          /**
                                                           * `true` if an inverted color scheme (a high contrast color scheme with light text
                                                           * and dark backgrounds) is being used, `false` otherwise.
                                                           */
                                                          invertedColorScheme: boolean) => void): this;
    once(event: 'inverted-color-scheme-changed', listener: (event: Event,
                                                          /**
                                                           * `true` if an inverted color scheme (a high contrast color scheme with light text
                                                           * and dark backgrounds) is being used, `false` otherwise.
                                                           */
                                                          invertedColorScheme: boolean) => void): this;
    addListener(event: 'inverted-color-scheme-changed', listener: (event: Event,
                                                          /**
                                                           * `true` if an inverted color scheme (a high contrast color scheme with light text
                                                           * and dark backgrounds) is being used, `false` otherwise.
                                                           */
                                                          invertedColorScheme: boolean) => void): this;
    removeListener(event: 'inverted-color-scheme-changed', listener: (event: Event,
                                                          /**
                                                           * `true` if an inverted color scheme (a high contrast color scheme with light text
                                                           * and dark backgrounds) is being used, `false` otherwise.
                                                           */
                                                          invertedColorScheme: boolean) => void): this;
    /**
     * Important: In order to properly leverage this API, you must set the
     * NSMicrophoneUsageDescription and NSCameraUsageDescription strings in your app's
     * Info.plist file. The values for these keys will be used to populate the
     * permission dialogs so that the user will be properly informed as to the purpose
     * of the permission request. See Electron Application Distribution for more
     * information about how to set these in the context of Electron. This user consent
     * was not required until macOS 10.14 Mojave, so this method will always return
     * true if your system is running 10.13 High Sierra or lower.
     */
    askForMediaAccess(mediaType: 'microphone' | 'camera'): Promise<boolean>;
    /**
     * NOTE: This API will return false on macOS systems older than Sierra 10.12.2.
     */
    canPromptTouchID(): boolean;
    /**
     * This API is only available on macOS 10.14 Mojave or newer.
     */
    getAccentColor(): string;
    /**
     * Returns an object with system animation settings.
     */
    getAnimationSettings(): AnimationSettings;
    /**
     * Gets the macOS appearance setting that you have declared you want for your
     * application, maps to NSApplication.appearance. You can use the
     * setAppLevelAppearance API to set this value.
     */
    getAppLevelAppearance(): ('dark' | 'light' | 'unknown');
    getColor(color: '3d-dark-shadow' | '3d-dark-shadow' | '3d-face' | '3d-highlight' | '3d-light' | '3d-shadow' | 'active-border' | 'active-caption' | 'active-caption-gradient' | 'app-workspace' | 'button-text' | 'caption-text' | 'desktop' | 'disabled-text' | 'highlight' | 'highlight-text' | 'hotlight' | 'inactive-border' | 'inactive-caption' | 'inactive-caption-gradient' | 'inactive-caption-text' | 'info-background' | 'info-text' | 'menu' | 'menu-highlight' | 'menubar' | 'menu-text' | 'scrollbar' | 'window' | 'window-frame' | 'window-text' | 'alternate-selected-control-text' | 'alternate-selected-control-text' | 'control-background' | 'control' | 'control-text' | 'disabled-control-text' | 'find-highlight' | 'grid' | 'header-text' | 'highlight' | 'keyboard-focus-indicator' | 'label' | 'link' | 'placeholder-text' | 'quaternary-label' | 'scrubber-textured-background' | 'secondary-label' | 'selected-content-background' | 'selected-control' | 'selected-control-text' | 'selected-menu-item' | 'selected-text-background' | 'selected-text' | 'separator' | 'shadow' | 'tertiary-label' | 'text-background' | 'text' | 'under-page-background' | 'unemphasized-selected-content-background' | 'unemphasized-selected-text-background' | 'unemphasized-selected-text' | 'window-background' | 'window-frame-text'): string;
    /**
     * Gets the macOS appearance setting that is currently applied to your application,
     * maps to NSApplication.effectiveAppearance Please note that until Electron is
     * built targeting the 10.14 SDK, your application's effectiveAppearance will
     * default to 'light' and won't inherit the OS preference. In the interim in order
     * for your application to inherit the OS preference you must set the
     * NSRequiresAquaSystemAppearance key in your apps Info.plist to false.  If you are
     * using electron-packager or electron-forge just set the enableDarwinDarkMode
     * packager option to true.  See the Electron Packager API for more details.
     */
    getEffectiveAppearance(): ('dark' | 'light' | 'unknown');
    /**
     * This user consent was not required until macOS 10.14 Mojave, so this method will
     * always return granted if your system is running 10.13 High Sierra or lower.
     */
    getMediaAccessStatus(mediaType: string): ('not-determined' | 'granted' | 'denied' | 'restricted' | 'unknown');
    /**
     * Returns one of several standard system colors that automatically adapt to
     * vibrancy and changes in accessibility settings like 'Increase contrast' and
     * 'Reduce transparency'. See Apple Documentation for  more details.
     */
    getSystemColor(color: 'blue' | 'brown' | 'gray' | 'green' | 'orange' | 'pink' | 'purple' | 'red' | 'yellow'): void;
    /**
     * Some popular key and types are:
     */
    getUserDefault(key: string, type: 'string' | 'boolean' | 'integer' | 'float' | 'double' | 'url' | 'array' | 'dictionary'): any;
    /**
     * An example of using it to determine if you should create a transparent window or
     * not (transparent windows won't work correctly when DWM composition is disabled):
     */
    isAeroGlassEnabled(): boolean;
    isDarkMode(): boolean;
    isHighContrastColorScheme(): boolean;
    isInvertedColorScheme(): boolean;
    isSwipeTrackingFromScrollEventsEnabled(): boolean;
    isTrustedAccessibilityClient(prompt: boolean): boolean;
    /**
     * Posts event as native notifications of macOS. The userInfo is an Object that
     * contains the user information dictionary sent along with the notification.
     */
    postLocalNotification(event: string, userInfo: any): void;
    /**
     * Posts event as native notifications of macOS. The userInfo is an Object that
     * contains the user information dictionary sent along with the notification.
     */
    postNotification(event: string, userInfo: any, deliverImmediately?: boolean): void;
    /**
     * Posts event as native notifications of macOS. The userInfo is an Object that
     * contains the user information dictionary sent along with the notification.
     */
    postWorkspaceNotification(event: string, userInfo: any): void;
    /**
     * This API itself will not protect your user data; rather, it is a mechanism to
     * allow you to do so. Native apps will need to set Access Control Constants like
     * kSecAccessControlUserPresence on the their keychain entry so that reading it
     * would auto-prompt for Touch ID biometric consent. This could be done with
     * node-keytar, such that one would store an encryption key with node-keytar and
     * only fetch it if promptTouchID() resolves. NOTE: This API will return a rejected
     * Promise on macOS systems older than Sierra 10.12.2.
     */
    promptTouchID(reason: string): Promise<void>;
    /**
     * Add the specified defaults to your application'